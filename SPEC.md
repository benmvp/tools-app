# Tools App - Project Specification

**Version:** 2.0
**Last Updated:** December 21, 2025
**Status:** Planning Phase

---

## Table of Contents

1. [Project Overview & Goals](#project-overview--goals)
2. [Technical Architecture](#technical-architecture)
3. [Tech Stack](#tech-stack)
4. [Monorepo Structure](#monorepo-structure)
5. [Shared Packages](#shared-packages)
6. [AI Content System](#ai-content-system)
7. [Application Specifications](#application-specifications)
8. [UI/UX Design](#uiux-design)
9. [Development Workflow](#development-workflow)
10. [Testing Strategy](#testing-strategy)
11. [Deployment & Infrastructure](#deployment--infrastructure)
12. [Implementation Plan](#implementation-plan)
13. [Future Enhancements](#future-enhancements)

---

## Project Overview & Goals

### Vision

Tools App is a suite of three web applications providing free, high-quality developer and financial tools. Each app focuses on a specific domain while sharing common infrastructure and design patterns.

### Applications

1. **Codemata** (codemata.benmvp.com) - Developer tools for code transformation

   - Code formatters (8 languages/formats)
   - Code minifiers (6 languages/formats)
   - Encoders/decoders (5 tools: JWT, Base64, URL, HTML Entity, JS String)
   - Future: Viewers, validators, generators, converters

2. **Moni** (moni.benmvp.com) - Financial calculators and planning tools

   - Savings & investment calculators
   - Debt management tools
   - Retirement planning calculators

3. **Convertly** (convertly.benmvp.com) - Unit conversion tools
   - Measurement converters (length, weight, volume, etc.)
   - Time and timezone conversion
   - Data size and numeral system conversion

### Primary Goals

1. **Utility-First:** Provide accurate, fast, and reliable tools that solve real problems
2. **Traffic & Engagement:** Build popular tools that attract consistent users
3. **Learning & Portfolio:** Showcase modern development practices and architecture
4. **Monetization:** Generate revenue through Google Ads (future phase)

### Success Metrics

- User engagement and repeat visits
- Tool accuracy and performance
- SEO rankings for tool-related keywords
- Ad revenue (future)

### Motivation

The project aims to create best-in-class online tools by combining:

- **Modern Tech:** Latest frameworks and libraries for optimal performance
- **AI-Enhanced Content:** High-quality, SEO-optimized educational content generated by AI
- **Developer-First:** Built by a developer, for developers (and anyone needing tools)
- **Scalable Architecture:** Monorepo structure allowing rapid addition of new tools

---

## Technical Architecture

### Architecture Overview

The project uses a **monorepo** structure with three independent Next.js applications sharing common packages. This architecture provides:

- **Code Reuse:** Shared UI components, configurations, and utilities
- **Consistency:** Unified development patterns across all apps
- **Flexibility:** Each app can be deployed and scaled independently
- **Maintainability:** Centralized tooling and dependency management

### Key Architectural Decisions

#### 1. Server-Side Transformations

All code transformations happen server-side via Next.js Server Actions:

- **Security:** No arbitrary code execution in browser
- **Bundle Size:** No heavy transformation libraries sent to client
- **Consistency:** Same transformation logic for all users
- **Simplicity:** Single source of truth for transformation logic

#### 2. AI Content Generation

Content is generated at build time and cached:

- **Build Time:** Gemini API generates all content during build
- **ISR:** 24-hour revalidation keeps content fresh without manual deploys
- **Fallback:** Cached content used if API fails during revalidation
- **Manual Regeneration:** `pnpm regenerate-ai` script for on-demand updates

#### 3. Static Routing with Dynamic Content

- **Static Routes:** All tool pages are pre-rendered at build time
- **Dynamic Content:** AI-generated content via ISR
- **SEO Optimized:** Fully crawlable, fast initial load

#### 4. Theme-Agnostic Shared Components

- Shared UI components accept theme configuration
- Each app defines its own color scheme
- Consistent layout and behavior across apps
- Easy branding customization per app

---

## Tech Stack

### Core Technologies

| Category            | Technology | Version | Purpose                    |
| ------------------- | ---------- | ------- | -------------------------- |
| **Runtime**         | Node.js    | Latest  | Server-side execution      |
| **Package Manager** | pnpm       | Latest  | Workspace management       |
| **Framework**       | Next.js    | Latest  | Full-stack React framework |
| **Language**        | TypeScript | Latest  | Type-safe development      |
| **Monorepo**        | Turborepo  | Latest  | Build orchestration        |

### Frontend Stack

| Category          | Technology      | Purpose                         |
| ----------------- | --------------- | ------------------------------- |
| **UI Components** | Radix UI        | Accessible primitives           |
| **UI Library**    | shadcn/ui       | Pre-built components            |
| **Styling**       | Tailwind CSS    | Utility-first styling           |
| **Code Editor**   | CodeMirror 6    | Syntax-highlighted input/output |
| **Icons**         | Lucide React    | Icon system                     |
| **Forms**         | React Hook Form | Form management                 |

### Backend & AI

| Category            | Technology              | Purpose             |
| ------------------- | ----------------------- | ------------------- |
| **AI Model**        | Gemini 3.0 Flash        | Content generation  |
| **Validation**      | Zod                     | Schema validation   |
| **Code Formatting** | Prettier, Biome         | Code transformation |
| **Minification**    | Terser, clean-css, etc. | Code minification   |

### Development Tools

| Category          | Technology | Purpose           |
| ----------------- | ---------- | ----------------- |
| **Linting**       | Biome      | Code linting      |
| **Type Checking** | TypeScript | Static analysis   |
| **Testing**       | Vitest     | Unit testing      |
| **Git Hooks**     | (Optional) | Pre-commit checks |

### Deployment

| Category      | Technology                | Purpose              |
| ------------- | ------------------------- | -------------------- |
| **Platform**  | Vercel                    | Hosting & deployment |
| **Domains**   | Custom domains            | Brand identity       |
| **Analytics** | Google Analytics (future) | User tracking        |
| **Ads**       | Google Ads (future)       | Monetization         |

---

## Monorepo Structure

### Directory Layout

```
tools-app/
├── apps/
│   ├── codemata/                 # Developer tools app
│   │   ├── app/                  # Next.js app directory
│   │   │   ├── layout.tsx        # Root layout
│   │   │   ├── page.tsx          # Home page
│   │   │   ├── formatters/       # Formatter tools
│   │   │   │   ├── info.ts       # Tool metadata
│   │   │   │   ├── formatters.ts # Tool configurations
│   │   │   │   ├── actions.ts    # Server actions
│   │   │   │   ├── ai.ts         # AI content generation
│   │   │   │   └── [slug]/       # Dynamic tool pages
│   │   │   │       └── page.tsx
│   │   │   └── minifiers/        # Minifier tools
│   │   │       └── ...           # Same structure
│   │   ├── components/           # App-specific components
│   │   ├── lib/                  # Utility functions
│   │   ├── public/               # Static assets
│   │   ├── styles/               # Global styles
│   │   ├── types.ts              # Shared types
│   │   ├── theme.ts              # App theme config
│   │   ├── next.config.mjs       # Next.js config
│   │   ├── tailwind.config.ts    # Tailwind config
│   │   ├── tsconfig.json         # TypeScript config
│   │   └── package.json          # Dependencies
│   │
│   ├── moni/                     # Financial tools app
│   │   └── ...                   # Similar structure
│   │
│   └── convertly/                # Conversion tools app
│       └── ...                   # Similar structure
│
├── packages/
│   ├── ui/                       # Shared UI components
│   │   ├── src/
│   │   │   ├── components/       # React components
│   │   │   │   ├── layout/       # Header, Footer, RootLayout
│   │   │   │   ├── transformer/  # Tool transformer UI
│   │   │   │   ├── content/      # Content sections
│   │   │   │   └── ui/           # shadcn/ui components
│   │   │   ├── lib/              # Utilities
│   │   │   ├── hooks/            # Custom hooks
│   │   │   └── types/            # Shared types
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   ├── typescript-config/        # Shared TS configs
│   │   ├── base.json
│   │   ├── nextjs.json
│   │   └── package.json
│   │
│   └── eslint-config/            # Shared ESLint configs
│       ├── base.js
│       ├── next.js
│       └── package.json
│
├── scripts/
│   └── regenerate-ai.js          # Manual AI content regeneration
│
├── .gitignore
├── pnpm-workspace.yaml           # pnpm workspace config
├── turbo.json                    # Turborepo config
├── package.json                  # Root package.json
├── README.md
├── TODO.md                       # Future features
└── SPEC.md                       # This document
```

### Workspace Configuration

**pnpm-workspace.yaml:**

```yaml
packages:
  - 'apps/*'
  - 'packages/*'
```

**Root package.json scripts:**

```json
{
  "scripts": {
    "dev": "turbo dev",
    "build": "turbo build",
    "start": "turbo start",
    "lint": "turbo lint",
    "type-check": "turbo type-check",
    "test": "turbo test",
    "format": "biome format --write .",
    "regenerate-ai": "node scripts/regenerate-ai.js"
  }
}
```

### Port Assignments

- **Codemata:** 3001 (dev), Production via Vercel
- **Moni:** 3002 (dev), Production via Vercel
- **Convertly:** 3003 (dev), Production via Vercel

---

## Shared Packages

### @repo/ui

The shared UI package provides theme-agnostic components used across all apps.

#### Components

**Layout Components:**

- `BaseRootLayout` - Root layout with theme provider, fonts, metadata
- `Header` - Top navigation with logo, menu, search, theme toggle
- `Footer` - Footer with links to benmvp.com, copyright, legal

**Tool Components:**

- `Transformer` - Dual CodeMirror editor with configuration and actions
- `ContentSection` - Collapsible section with heading and markdown content
- `ContentSections` - Wrapper for multiple content sections

**UI Primitives (shadcn/ui):**

- Button, Card, Dialog, Dropdown Menu
- Accordion, Tabs, Toast
- Form components

#### Theme System

Components accept theme configuration via context:

```typescript
interface AppTheme {
  colors: {
    primary: string      // Tailwind color class (e.g., 'blue')
    secondary: string
    accent: string
  }
  brand: {
    name: string
    logo: React.ReactNode
    url: string
  }
}

// Each app provides its theme
const codeMataTheme: AppTheme = { ... }
const moniTheme: AppTheme = { ... }
const convertlyTheme: AppTheme = { ... }
```

#### Package Structure

```
packages/ui/
├── src/
│   ├── components/
│   │   ├── layout/
│   │   │   ├── header.tsx
│   │   │   ├── footer.tsx
│   │   │   └── base-root-layout.tsx
│   │   ├── transformer/
│   │   │   ├── transformer.tsx
│   │   │   ├── code-editor.tsx
│   │   │   └── config-panel.tsx
│   │   ├── content/
│   │   │   ├── content-section.tsx
│   │   │   └── content-sections.tsx
│   │   └── ui/              # shadcn/ui components
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       └── ...
│   ├── lib/
│   │   └── utils.ts
│   ├── hooks/
│   │   └── use-theme.ts
│   └── types/
│       └── index.ts
├── package.json
└── tsconfig.json
```

### @repo/typescript-config

Shared TypeScript configurations:

- **base.json** - Base config with strict settings
- **nextjs.json** - Extends base, adds Next.js specific options

### @repo/eslint-config

Shared ESLint configurations:

- **base.js** - Base rules for all projects
- **next.js** - Next.js specific rules
- **react.js** - React specific rules

---

## AI Content System

### Overview

The AI Content System uses Google Gemini to generate high-quality, SEO-optimized educational content for each tool. This system transforms simple code transformation tools into comprehensive educational resources that:

- **Drive Organic Traffic:** SEO-optimized content targeting long-tail keywords related to each tool
- **Increase User Engagement:** Educational material including how-to guides, best practices, FAQs, and contextual tips
- **Establish Authority:** Comprehensive information about each tool, its domain, and integration workflows
- **Scale Efficiently:** Smart pre-rendering in production, on-demand in preview/dev
- **Stay Fresh:** Automatic 24-hour revalidation keeps content current without manual intervention
- **Cost-Optimized:** Production builds pre-render for SEO, preview/dev use on-demand to save API costs
- **Developer-Friendly:** Skip AI in local dev to preserve API quota during hot-reload

**Strategy:** Hybrid approach - pre-render in production for SEO, on-demand ISR elsewhere for cost efficiency.

### Build & Rendering Strategy

The system uses a **convention-based approach** with automatic environment detection. No configuration needed for typical scenarios - just set `GOOGLE_API_KEY` and everything works:

**Production Builds (`VERCEL_ENV=production`):**
- Pre-render ALL pages with AI content during build
- Ensures search engine crawlers get instant, fully-rendered pages
- Optimal SEO performance with fast initial loads
- AI content baked into static HTML
- Link prefetching enabled for instant navigation

**Preview Builds (`VERCEL_ENV=preview`):**
- No pre-rendering - pages generated on first request (saves API costs)
- AI generation on-demand for visited pages only
- Link prefetching disabled (prevents automatic generation)
- ISR caching works for subsequent requests
- Good for testing without incurring full build costs

**Local Development (`next dev`):**
- No pre-rendering (development mode)
- AI generation DISABLED automatically (no `VERCEL_ENV` set)
- Preserves API quota during hot-reload cycles
- Pages work perfectly without AI content (graceful degradation)
- **Enable AI:** Set `VERCEL_ENV=preview` + `NEXT_PUBLIC_VERCEL_ENV=preview` to test AI locally

**Local Production Builds (`next build` without `VERCEL_ENV`):**
- Pre-renders all pages (NODE_ENV=production)
- AI generation ENABLED by default (full production behavior)
- Link prefetching enabled
- Override: Set `DISABLE_AI=true` to pre-render without AI content
- Note: Setting `VERCEL_ENV="production"` is unnecessary - `next build` already defaults to production mode

**Environment Detection Logic:**
```typescript
// Pre-rendering decision (independent of AI)
function getEnvironmentMode(): 'development' | 'preview' | 'production' {
  const vercelEnv = process.env.VERCEL_ENV || process.env.NEXT_PUBLIC_VERCEL_ENV
  if (vercelEnv) return vercelEnv as typeof mode
  return process.env.NODE_ENV === 'production' ? 'production' : 'development'
}

// AI generation decision (checks DISABLE_AI separately)
function shouldGenerateAI(): boolean {
  if (process.env.DISABLE_AI === 'true') return false
  return getEnvironmentMode() !== 'development'
}

// Pre-rendering happens whenever environment is 'production'
// AI generation is separate - can pre-render without AI
### Content Generation Flow

```
Production Build (VERCEL_ENV=production or NODE_ENV=production):
1. Next.js pre-renders all tool pages
2. For each page: Call Gemini API for content
3. Generate complete HTML with AI content
4. Deploy with all pages ready
5. Crawlers get instant pages (good SEO)
6. ISR revalidates every 24 hours
7. Link prefetching enabled

Preview Build (VERCEL_ENV=preview):
1. Next.js builds without pre-rendering
2. Deploy to Vercel
3. First request: Generate AI content on-demand
4. Cache for 24 hours
5. Subsequent requests use cache
6. Link prefetching disabled (saves API costs)

Local Dev (next dev):
1. No pre-rendering
2. AI generation skipped (mode=disabled)
3. Pages load without AI content
4. Tool functionality works perfectly

Local Production Build (next build, no VERCEL_ENV):
1. Pre-renders all pages (environment=production)
2. AI generation enabled by default
3. Full production behavior
4. Use DISABLE_AI=true to pre-render without AI content
5. Pages work perfectly without AI (graceful degradation)

Runtime (ISR - After 24 Hours):
1. User requests page with stale cache
2. Return cached version immediately
3. Background: Trigger revalidation
4. Call Gemini API for fresh content
5. Update cache with new content
6. If API fails: Keep existing cached content

Error Handling:
1. If AI generation fails, page still works
2. Tool functionality always available
3. Content sections gracefully hidden if unavailable
4. No broken pages or build failures

Manual Regeneration:
1. Run `pnpm regenerate-ai` script
2. Trigger on-demand revalidation for all pages
3. Fresh content generated for selected tools
```

### Environment Variables

**Required (Production/Testing):**
- `GOOGLE_API_KEY` - Google AI API key for Gemini API

**Optional (Testing/Override):**
- `DISABLE_AI` - Set to `"true"` to force disable AI in any environment
- `VERCEL_ENV` - Override environment mode: `"production"`, `"preview"`, or `"development"`
- `NEXT_PUBLIC_VERCEL_ENV` - Client-side environment mode (set to same value as `VERCEL_ENV`)

**Automatic (No Configuration Needed):**
- Vercel automatically sets `VERCEL_ENV` and `NEXT_PUBLIC_VERCEL_ENV`
- Local `next dev` runs with AI disabled (no VERCEL_ENV)
- Local `next build` runs with AI enabled (NODE_ENV=production fallback)

**Testing Scenarios:**

```bash
# .env.local examples:

# Enable AI in local dev (on-demand generation, no prefetch)
# Useful for testing AI without doing full production build
VERCEL_ENV="preview"
NEXT_PUBLIC_VERCEL_ENV="preview"

# Force disable AI but still pre-render pages
# Useful for testing static pages without AI costs
DISABLE_AI="true"

# Note: Local production builds (next build) work out-of-the-box:
# - Automatically pre-renders all pages
# - Enables AI generation by default
# - No VERCEL_ENV="production" needed
```

### Gemini API Configuration

**Model:** `gemini-2.0-flash` (or latest available)

**API Integration:**

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai'

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!)
const model = genAI.getGenerativeModel({
  model: 'gemini-2.0-flash',
  generationConfig: {
    responseMimeType: 'application/json',
    responseSchema: toolContentSchema, // Zod to JSON Schema
  },
})
```

**Environment Variables:**

- `GOOGLE_API_KEY` - Google AI API key (required)

### Content Schema

All AI-generated content follows a strict Zod schema:

```typescript
import { z } from 'zod'

const contentSectionSchema = z.object({
  heading: z.string().describe('Section heading'),
  content: z.string().describe('Markdown formatted content'),
})

const toolContentSchema = z.object({
  intro: z.string().describe('Introductory paragraph (1-2 sentences)'),

  seo: z.object({
    title: z.string().describe('Page title (50-60 chars)'),
    description: z.string().describe('Meta description (150-160 chars)'),
    keywords: z.string().describe('Comma-separated keywords'),
  }),

  // OpenGraph metadata for social sharing
  openGraph: z.object({
    title: z.string().describe('OG title (can be longer than SEO title)'),
    description: z.string().describe('OG description (can be longer)'),
    type: z.literal('website'),
  }),

  // Main content sections
  howToUse: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: numbered list of 3-5 steps'),
  }).optional(),

  features: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: bulleted list of features/benefits'),
  }),

  rationale: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: why use this tool'),
  }),

  purpose: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: what is this language/format'),
  }),

  integrate: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: workflow integration tips'),
  }),

  faq: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: 3-5 Q&A pairs'),
  }),

  recommendations: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: related tool links'),
    tools: z.array(z.string()).describe('Tool IDs recommended by AI'),
  }),

  resources: z.object({
    heading: z.string(),
    content: z.string().describe('Markdown: external resource links'),
  }),

  // Enhanced features
  tips: z.array(
    z.object({
      type: z.enum(['tip', 'fact', 'bestPractice']),
      content: z.string().describe('Short, actionable tip or fact'),
    })
  ).describe('3-5 contextual tips, facts, or best practices'),

  // Legacy field kept for compatibility
  old_seo: z.object({
    title: z.string().describe('Page title (50-60 chars)'),
    description: z.string().describe('Meta description (150-160 chars)'),
    keywords: z.string().describe('Comma-separated keywords'),
  }),

  // OpenGraph metadata for social sharing
  openGraph: z.object({
    title: z.string().describe('OG title (can be longer than SEO title)'),
    description: z.string().describe('OG description (can be longer)'),
    type: z.literal('website'),
    image: z.string().optional().describe('OG image URL (optional)'),
  }),

  // Comprehensive content sections
  howToUse: z.object({
    title: z.string().describe('Page title (50-60 chars)'),
    description: z.string().describe('Meta description (150-160 chars)'),
    keywords: z.string().describe('Comma-separated keywords'),
  }),

  howToUse: contentSectionSchema
    .optional()
    .describe('Step-by-step instructions (optional, users usually understand)'),

  features: contentSectionSchema.describe('Features and benefits of the tool'),

  rationale: contentSectionSchema.describe(
    'Why use this tool / online formatter',
  ),

  purpose: contentSectionSchema.describe(
    'What is the language/format this tool works with',
  ),

  integrate: contentSectionSchema.describe(
    'How to integrate formatting into workflow',
  ),

  faq: contentSectionSchema.describe('Frequently asked questions and answers'),

  recommendations: contentSectionSchema.describe(
    'Links to other related tools on the site',
  ),

  resources: contentSectionSchema.describe(
    'External resources and documentation links',
  ),
})

export type ToolContent = z.infer<typeof toolContentSchema>
```

**Validation Flow:**

1. Gemini returns JSON matching schema
2. Zod validates structure and types
3. Convert to TypeScript object (fully typed)
4. Use throughout app with type safety

### AI Prompts

The AI prompt system consists of a system message (context) and user message (specific request).

#### System Message Template

```markdown
You are a copywriter and SEO expert for an application called **{APP_NAME}** that provides developer tools.

Your task is to generate content for various online {TOOL_TYPE} tools that {APP_NAME} offers. The content will be used to create web pages for each tool, providing information on how to use the tool, its features, benefits, and integration options.

## Tone and Style

- Friendly and approachable
- Educational and helpful
- Use clear and concise language
- Use bullet points and numbered lists for easy readability
- Write in a way that is easy to understand for both novice and experienced developers

## Content Sections

### Introductory Paragraph (intro)

- A single paragraph (1-2 sentences) explaining the purpose of the tool
- Highlight the benefits: cleaning messy code, improving readability, consistency
- Mention configuration options (e.g., indentation)
- Target audience: developers
- Adapt to be specific to the language being formatted
- Output: Plain text (no markdown)
- Example: "Tired of messy HTML code? Our free online HTML formatter instantly cleans up your code, making it easier to understand and maintain. Choose from various indentation options to match your coding style."

### SEO Metadata (seo)

- **title**: Page title optimized for search (50-60 characters)
  - Format: "{Language/Format} {Tool Type} | {App Name}"
  - Example: "JavaScript & TypeScript Formatter | Codemata Developer Tools"
- **description**: Meta description for search results (150-160 characters)
  - Include tool name, key benefit, and call-to-action
  - Example: "Format and beautify JavaScript & TypeScript code instantly. Free online formatter with customizable indentation. Clean, readable code in seconds."
- **keywords**: Comma-separated keywords for SEO
  - Include: tool type, language, variations, use cases
  - Example: "javascript formatter, typescript formatter, js beautifier, code formatter, prettier online"

### How to Use (howToUse) - Optional

- **heading**: Suggest a relevant heading (e.g., "How to use the HTML Formatter")
- **content**: Numbered list (3-5 steps) with clear instructions
  - Paste code → Select options → View result → Copy output
  - Keep it simple, users generally understand how tools work
- Output: Markdown format

### Features and Benefits (features)

- **heading**: Suggest relevant heading (e.g., "Features and benefits")
- **content**: Bulleted list highlighting tool features
  - Focus on user value and benefits
  - Include: automatic formatting, customizable options, fast performance
  - Add language-specific features where relevant
- Output: Markdown format

### Rationale (rationale)

- **heading**: Suggest heading (e.g., "Why use an online HTML Formatter?")
- **content**: Bulleted list explaining benefits
  - Address developer pain points
  - Benefits: readability, debugging, consistency, collaboration, time savings
  - Tailor to specific language while keeping general benefits
- Output: Markdown format

### Purpose (purpose)

- **heading**: Language explanation (e.g., "What is GraphQL?", "What is XML?")
- **content**: Brief paragraph explaining the language/format
  - What it is and its role
  - Common use cases
  - Why formatting matters for this language
- Output: Markdown format

### Integration (integrate)

- **heading**: Workflow integration (e.g., "Integrating formatting into your workflow")
- **content**: Tips for using the tool in development workflow
  - Editor plugins and extensions
  - CI/CD integration
  - Git hooks
  - Team standards
- Output: Markdown format

### FAQ (faq)

- **heading**: "Frequently Asked Questions"
- **content**: 3-5 common questions and concise answers
  - Format as markdown with **Q:** and **A:**
  - Address: tool usage, options, privacy, cost, language support
- Output: Markdown format

### Recommendations (recommendations)

- **heading**: "Related Tools"
- **content**: Links to other tools on the site
  - Reference the available tools list provided
  - Suggest 3-5 relevant tools
  - Format as markdown links: `- [Tool Name](url) - Brief description`
- Output: Markdown format

### Resources (resources)

- **heading**: "External Resources"
- **content**: Links to official documentation and learning resources
  - Official language/format documentation
  - Style guides and best practices
  - Popular formatters and tools
  - Format as markdown links with descriptions
- Output: Markdown format

## Important Guidelines

- Be specific to the language/format being discussed
- Use concrete examples where helpful
- Keep content scannable with headings and lists
- Maintain consistent, friendly tone throughout
- Optimize for SEO without keyword stuffing
- Ensure all content is accurate and up-to-date
```

#### User Message Template

```markdown
Generate the content for the following {TOOL_TYPE} tool: {TOOL_NAME}

All available tools on the site:
{AVAILABLE_TOOLS_LIST}

Remember to:

- Make content specific to {LANGUAGE/FORMAT}
- Include relevant keywords naturally
- Link to related tools from the available tools list
- Keep tone friendly and educational
```

#### Example: CSS Formatter

**System Message:** (As above, with APP_NAME=Codemata, TOOL_TYPE=formatter)

**User Message:**

```
Generate the content for the following formatter tool: CSS/SCSS Formatter

All available tools:
- CSS/SCSS Formatter - /css-formatter
- GraphQL Formatter - /graphql-formatter
- HTML Formatter - /html-formatter
- JSON Formatter - /json-formatter
- JavaScript & TypeScript Formatter - /typescript-formatter
- Markdown/MDX Formatter - /markdown-formatter
- XML Formatter - /xml-formatter
- YAML Formatter - /yaml-formatter
- CSS Minifier - /css-minifier
- HTML Minifier - /html-minifier
- JSON Minifier - /json-minifier
- JavaScript & TypeScript Minifier - /typescript-minifier
- SVG Minifier - /svg-minifier
- XML Minifier - /xml-minifier
```

### Caching Strategy

**Production Cache:**

```typescript
// In-memory cache for API requests during build
const REQUEST_CACHE = new Map<string, ToolContent>()

async function getCachedToolContent(
  cacheKey: string,
  systemMessage: string,
  userMessage: string,
): Promise<ToolContent | undefined> {
  // Check in-memory cache first
  if (REQUEST_CACHE.has(cacheKey)) {
    return REQUEST_CACHE.get(cacheKey)
  }

  // Generate new content
  const content = await generateToolContent(systemMessage, userMessage)

  // Cache the result
  REQUEST_CACHE.set(cacheKey, content)

  return content
}
```

**ISR Configuration:**

```typescript
// In page.tsx
export const revalidate = 86400 // 24 hours

export async function generateMetadata({ params }) {
  const toolContent = await getToolContent(params.slug)
  // ... return metadata
}
```

**Error Handling:**

```typescript
async function getToolContent(slug: string): Promise<ToolContent | undefined> {
  try {
    const content = await getCachedToolContent(...)
    return content
  } catch (error) {
    console.error('AI generation failed:', error)

    // During build: fail fast
    if (process.env.NODE_ENV === 'production' && !isRevalidation()) {
      throw error
    }

    // During ISR revalidation: use cached version
    return getCachedVersion(slug) // Return existing cached page
  }
}
```

### Manual Regeneration Script

**scripts/regenerate-ai.js:**

```javascript
#!/usr/bin/env node

/**
 * Manually trigger revalidation for tool pages
 * Usage: node scripts/regenerate-ai.js [app] [slug]
 * Example: node scripts/regenerate-ai.js codemata typescript-formatter
 */

const apps = ['codemata', 'moni', 'convertly']
const targetApp = process.argv[2]
const targetSlug = process.argv[3]

if (targetApp && !apps.includes(targetApp)) {
  console.error(`Invalid app: ${targetApp}`)
  process.exit(1)
}

// Trigger on-demand revalidation via Vercel API
// or use fetch to hit revalidate endpoint
async function revalidate(app, slug) {
  const url = `https://${app}.benmvp.com/${slug}`
  const revalidateUrl = `https://${app}.benmvp.com/api/revalidate?path=/${slug}&secret=${process.env.REVALIDATE_SECRET}`

  await fetch(revalidateUrl)
  console.log(`Revalidated: ${url}`)
}

// Main execution
// ... implementation
```

---

## Application Specifications

### Codemata (Developer Tools)

**Domain:** codemata.benmvp.com
**Purpose:** Code transformation tools for developers

#### Tool Categories

**1. Formatters** - Beautify and format code with consistent styling

| Tool ID   | Display Name | Languages                        | Library                         | Config      |
| --------- | ------------ | -------------------------------- | ------------------------------- | ----------- |
| `css`     | CSS/SCSS     | CSS, SCSS                        | Prettier                        | Indentation |
| `graphql` | GraphQL      | GraphQL                          | Prettier                        | Indentation |
| `html`    | HTML         | HTML                             | Prettier                        | Indentation |
| `json`    | JSON         | JSON                             | Prettier                        | Indentation |
| `md`      | Markdown/MDX | Markdown, MDX                    | Prettier                        | Indentation |
| `ts`      | JS/TS        | JavaScript, TypeScript, JSX, TSX | Biome/Prettier                  | Indentation |
| `xml`     | XML          | XML                              | Prettier + @prettier/plugin-xml | Indentation |
| `yaml`    | YAML         | YAML                             | Prettier                        | Indentation |

**2. Minifiers** - Compress code by removing whitespace and optimizing

| Tool ID | Display Name | Languages              | Library              | Config |
| ------- | ------------ | ---------------------- | -------------------- | ------ |
| `css`   | CSS          | CSS                    | clean-css            | None   |
| `html`  | HTML         | HTML                   | html-minifier-terser | None   |
| `json`  | JSON         | JSON                   | JSON.stringify       | None   |
| `svg`   | SVG          | SVG                    | svgo                 | None   |
| `ts`    | JS/TS        | JavaScript, TypeScript | Terser               | None   |
| `xml`   | XML          | XML                    | minify-xml           | None   |

#### Route Structure

```
/                           - Home page (hero + categories + tool grid)
/typescript-formatter       - JS/TS formatter tool page
/json-formatter            - JSON formatter tool page
/css-formatter             - CSS formatter tool page
... (all formatters)
/typescript-minifier       - JS/TS minifier tool page
/json-minifier             - JSON minifier tool page
... (all minifiers)
```

#### Tool Configuration

**Formatter Configuration Example:**

```typescript
// apps/codemata/app/formatters/formatters.ts

import type { TransformerConfig } from '../../types'

export type Indentation = 'two-spaces' | 'four-spaces' | 'tabs'

export const indentationConfig: TransformerConfig<Indentation> = {
  id: 'indentation',
  label: 'Indentation',
  options: [
    { label: 'Two Spaces', value: 'two-spaces' },
    { label: 'Four Spaces', value: 'four-spaces' },
    { label: 'Tabs', value: 'tabs' },
  ],
}

export interface Formatter {
  action: (input: string, config: FormatterConfig) => Promise<string>
  configs: TransformerConfig[]
}

const typescriptFormatter: Formatter = {
  action: formatTypescriptAction,
  configs: [indentationConfig],
}

export const FORMATTERS: Record<FormatterId, Formatter> = {
  ts: typescriptFormatter,
  json: jsonFormatter,
  // ... rest
}
```

**Tool Metadata Example:**

```typescript
// apps/codemata/app/formatters/info.ts

import type { TransformerInfo } from '../../types'
import CodeIcon from '@mui/icons-material/Code'

type FormatterInfo = TransformerInfo<FormatterId>

const TS: FormatterInfo = {
  id: 'ts',
  slug: 'typescript',
  displayName: 'JS/TS',
  pageTitle: 'JavaScript & TypeScript Formatter',
  Icon: CodeIcon,
  url: '/typescript-formatter',
}

export const FORMATTERS_INFO: Record<FormatterId, FormatterInfo> = {
  ts: TS,
  json: JSON,
  // ... rest
}
```

#### Server Actions

**Formatter Action Example:**

```typescript
// apps/codemata/app/formatters/actions.ts

'use server'

import { format } from 'prettier'
import type { Indentation } from './types'

export async function formatTypescriptAction(
  input: string,
  config: { indentation: Indentation },
): Promise<string> {
  const indent = getIndentSize(config.indentation)

  try {
    const formatted = await format(input, {
      parser: 'typescript',
      tabWidth: indent.size,
      useTabs: indent.useTabs,
      semi: true,
      singleQuote: true,
      trailingComma: 'es5',
    })

    return formatted
  } catch (error) {
    throw new Error(`Formatting failed: ${error.message}`)
  }
}

function getIndentSize(indentation: Indentation) {
  switch (indentation) {
    case 'two-spaces':
      return { size: 2, useTabs: false }
    case 'four-spaces':
      return { size: 4, useTabs: false }
    case 'tabs':
      return { size: 2, useTabs: true }
  }
}
```

#### Page Implementation

```typescript
// apps/codemata/app/formatters/[slug]/page.tsx

import { notFound } from 'next/navigation'
import { TransformerUi } from '@repo/ui/components/transformer'
import { ContentSectionsUi } from '@repo/ui/components/content'
import { getFormatterContent } from '../ai'
import { FORMATTERS, FORMATTERS_INFO } from '../formatters'

// ISR configuration
export const revalidate = 86400 // 24 hours

// Static params for build
export function generateStaticParams() {
  return Object.values(FORMATTERS_INFO).map(({ slug }) => ({
    slug
  }))
}

// Metadata generation
export async function generateMetadata({ params }) {
  const formatter = getFormatterBySlug(params.slug)
  if (!formatter) return notFound()

  const content = await getFormatterContent(formatter.id)

  return {
    title: content?.seo.title || formatter.pageTitle,
    description: content?.seo.description,
    keywords: content?.seo.keywords
  }
}

// Page component
export default async function FormatterPage({ params }) {
  const formatter = getFormatterBySlug(params.slug)
  if (!formatter) return notFound()

  const content = await getFormatterContent(formatter.id)
  const tool = FORMATTERS[formatter.id]

  return (
    <>
      <h1>{formatter.pageTitle}</h1>

      {content?.intro && <p>{content.intro}</p>}

      <TransformerUi
        action={tool.action}
        configs={tool.configs}
        actionLabel="Format"
        stateLabel="Formatted"
        displayName={formatter.displayName}
      />

      <ContentSectionsUi
        sections={[
          content?.features,
          content?.rationale,
          content?.purpose,
          content?.integrate,
          content?.faq,
          content?.recommendations,
          content?.resources
        ].filter(Boolean)}
      />
    </>
  )
}
```

#### Theme Configuration

```typescript
// apps/codemata/theme.ts

export const codeMataTheme = {
  colors: {
    primary: 'blue', // Tailwind color
    secondary: 'slate',
    accent: 'cyan',
  },
  brand: {
    name: 'Codemata',
    url: 'https://codemata.benmvp.com',
    tagline: 'Developer Tools',
  },
}
```

### Moni (Financial Tools)

**Domain:** moni.benmvp.com
**Purpose:** Financial calculators and planning tools

#### Tool Categories

See TODO.md for complete list. Key categories:

- **Savings & Investment:** Compound interest, savings goals, retirement planning
- **Debt Management:** Loan calculators, debt payoff strategies
- **Utilities:** Currency converter, tip calculator, net worth calculator

#### Route Structure

```
/                              - Home page
/compound-interest-calculator  - Calculator page
/savings-goal-calculator       - Calculator page
... (all calculators)
```

#### Calculator Pattern

Similar structure to Codemata but with calculator-specific components:

```typescript
// Calculator configuration
interface Calculator {
  action: (inputs: CalculatorInputs) => Promise<CalculatorResults>
  inputs: InputField[]
  resultFormat: ResultDisplay
}

// Calculator page renders:
// 1. Calculator form (inputs)
// 2. Results display (charts + breakdown)
// 3. AI-generated educational content
```

#### Theme Configuration

```typescript
// apps/moni/theme.ts

export const moniTheme = {
  colors: {
    primary: 'green', // Financial/money color
    secondary: 'slate',
    accent: 'emerald',
  },
  brand: {
    name: 'Moni',
    url: 'https://moni.benmvp.com',
    tagline: 'Financial Tools',
  },
}
```

### Convertly (Conversion Tools)

**Domain:** convertly.benmvp.com
**Purpose:** Unit and format conversion tools

#### Tool Categories

See TODO.md for complete list. Key categories:

- **Measurement:** Length, weight, volume, temperature, area
- **Time:** Time zones, time units
- **Data:** Data sizes, numeral systems
- **Text:** Morse code, Roman numerals

#### Route Structure

```
/                        - Home page
/length-converter        - Converter page
/temperature-converter   - Converter page
... (all converters)
```

#### Theme Configuration

```typescript
// apps/convertly/theme.ts

export const convertlyTheme = {
  colors: {
    primary: 'purple', // Conversion/transformation color
    secondary: 'slate',
    accent: 'violet',
  },
  brand: {
    name: 'Convertly',
    url: 'https://convertly.benmvp.com',
    tagline: 'Conversion Tools',
  },
}
```

---

## UI/UX Design

### Design System

#### Color System

Each app uses a primary color with Tailwind CSS:

**Codemata:** Blue theme

- Primary: `blue-600` (#2563eb)
- Hover: `blue-700` (#1d4ed8)
- Light: `blue-50` (#eff6ff)

**Moni:** Green theme

- Primary: `green-600` (#16a34a)
- Hover: `green-700` (#15803d)
- Light: `green-50` (#f0fdf4)

**Convertly:** Purple theme

- Primary: `purple-600` (#9333ea)
- Hover: `purple-700` (#7e22ce)
- Light: `purple-50` (#faf5ff)

**Neutral Colors:** All apps share neutral colors

- Gray: `slate-*` scale
- Text: `slate-900` (dark), `slate-50` (light)
- Border: `slate-200` (light), `slate-700` (dark)

#### Typography

**Font System:**

```typescript
// Next.js font configuration
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
})

// Tailwind typography scale
const typography = {
  h1: 'text-4xl font-bold', // Page titles
  h2: 'text-3xl font-bold', // Section headings
  h3: 'text-2xl font-semibold', // Subsection headings
  body: 'text-base', // Body text
  small: 'text-sm', // Secondary text
  code: 'font-mono text-sm', // Code/technical text
}
```

#### Spacing & Layout

**Container:**

- Max width: `1280px` (container)
- Padding: `px-4` mobile, `px-6` tablet, `px-8` desktop
- Gap: `space-y-8` for vertical sections

**Grid System:**

```typescript
// Tool grid (home page)
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
  {tools.map(tool => <ToolCard key={tool.id} {...tool} />)}
</div>

// Transformer layout
<div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
  <CodeEditor label="Input" />
  <CodeEditor label="Output" />
</div>
```

#### Responsive Breakpoints

```typescript
// Tailwind breakpoints
{
  sm: '640px',   // Mobile landscape
  md: '768px',   // Tablet
  lg: '1024px',  // Desktop
  xl: '1280px',  // Large desktop
  '2xl': '1536px' // Extra large
}
```

**Responsive Patterns:**

- Mobile: Single column, stacked editors
- Tablet: Two columns for editors, grid layouts
- Desktop: Full grid layouts, side-by-side editors

#### Dark Mode

**Implementation:** Tailwind CSS dark mode with class strategy

```typescript
// tailwind.config.ts
export default {
  darkMode: 'class',
  // ...
}

// Theme toggle stores preference in localStorage
// Root layout applies 'dark' class to <html>
```

**Color Adjustments:**

```css
/* Light mode */
.bg-background {
  @apply bg-white;
}
.text-foreground {
  @apply text-slate-900;
}

/* Dark mode */
.dark .bg-background {
  @apply bg-slate-950;
}
.dark .text-foreground {
  @apply text-slate-50;
}
```

### Component Library (shadcn/ui)

**Core Components to Install:**

```bash
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
npx shadcn-ui@latest add accordion
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add dropdown-menu
npx shadcn-ui@latest add form
npx shadcn-ui@latest add input
npx shadcn-ui@latest add label
npx shadcn-ui@latest add select
npx shadcn-ui@latest add toast
npx shadcn-ui@latest add tooltip
```

**Customization:**
All components customized with theme colors via CSS variables:

```css
@layer base {
  :root {
    --primary: 217 91% 60%; /* blue-600 */
    --primary-foreground: 0 0% 100%;
    /* ... other colors */
  }

  .dark {
    --primary: 217 91% 60%;
    --primary-foreground: 0 0% 100%;
    /* ... dark mode colors */
  }
}
```

### Layout Components

#### Header

**Structure:**

```
┌─────────────────────────────────────────────┐
│ [Logo] Codemata          [Search] [Theme]   │
│        ▾ Formatters ▾ Minifiers             │
└─────────────────────────────────────────────┘
```

**Features:**

- Logo with app name
- Dropdown navigation for tool categories
- Search icon (opens search modal)
- Theme toggle (sun/moon icon)
- Responsive: Hamburger menu on mobile

**Implementation:**

```tsx
// @repo/ui/components/layout/header.tsx
export function Header({ theme, categories }: HeaderProps) {
  return (
    <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur">
      <div className="container flex h-16 items-center justify-between">
        <div className="flex items-center gap-6">
          <Link href="/" className="flex items-center gap-2">
            {theme.brand.logo}
            <span className="font-bold">{theme.brand.name}</span>
          </Link>

          <nav className="hidden md:flex gap-4">
            {categories.map((category) => (
              <DropdownMenu key={category.id}>
                <DropdownMenuTrigger>{category.name}</DropdownMenuTrigger>
                <DropdownMenuContent>
                  {category.tools.map((tool) => (
                    <DropdownMenuItem key={tool.id} asChild>
                      <Link href={tool.url}>{tool.displayName}</Link>
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            ))}
          </nav>
        </div>

        <div className="flex items-center gap-2">
          <Button variant="ghost" size="icon" onClick={openSearch}>
            <SearchIcon />
          </Button>
          <ThemeToggle />
        </div>
      </div>
    </header>
  )
}
```

#### Footer

**Structure:**

```
┌─────────────────────────────────────────────┐
│ © 2025 BenMVP                               │
│ [Link to benmvp.com]                        │
└─────────────────────────────────────────────┘
```

**Features:**

- Copyright notice
- Link to benmvp.com
- Simple, minimal design

#### Home Page

**Layout:**

1. **Hero Section** - Value proposition and search
2. **Category Cards** - Visual grid of tool categories
3. **Tool Grid** - All tools organized by category

**Hero Example:**

```tsx
<section className="py-20 text-center">
  <h1 className="text-5xl font-bold mb-4">
    Developer Tools for the Modern Web
  </h1>
  <p className="text-xl text-muted-foreground mb-8">
    Format, minify, and transform code instantly
  </p>
  <div className="max-w-md mx-auto">
    <SearchInput placeholder="Search tools..." />
  </div>
</section>
```

**Category Card:**

```tsx
<Card className="hover:shadow-lg transition-shadow">
  <CardHeader>
    <div className="w-12 h-12 rounded-lg bg-primary/10 flex items-center justify-center mb-4">
      <CategoryIcon className="w-6 h-6 text-primary" />
    </div>
    <CardTitle>Formatters</CardTitle>
    <CardDescription>
      Beautify and format code with consistent styling
    </CardDescription>
  </CardHeader>
  <CardContent>
    <div className="flex flex-wrap gap-2">
      {tools.map((tool) => (
        <Link key={tool.id} href={tool.url}>
          <Badge variant="secondary">{tool.displayName}</Badge>
        </Link>
      ))}
    </div>
  </CardContent>
</Card>
```

### Tool Page Layout

**Structure:**

```
┌────────────────────────────────────┐
│ JavaScript & TypeScript Formatter  │ ← Page title
│                                    │
│ Intro paragraph from AI...         │ ← AI content
│                                    │
│ ┌──────────────┬──────────────┐   │
│ │ Input        │ Output       │   │ ← Transformer
│ │ [CodeEditor] │ [CodeEditor] │   │
│ │              │              │   │
│ └──────────────┴──────────────┘   │
│ [ Indentation: ▾ ] [Format] ✓     │ ← Config + Action
│                                    │
│ ▼ Features and Benefits            │ ← AI content (expanded)
│   - Automatic indentation...       │
│                                    │
│ ▶ Why use this tool?               │ ← AI content (collapsed)
│ ▶ What is TypeScript?              │
│ ▶ Integration tips                 │
│ ▶ FAQ                              │
│ ▶ Related Tools                    │
│ ▶ Resources                        │
└────────────────────────────────────┘
```

### Transformer Component

**Core component for all code transformation tools:**

```tsx
// @repo/ui/components/transformer/transformer.tsx

interface TransformerProps {
  action: (input: string, config: any) => Promise<string>
  configs?: TransformerConfig[]
  actionLabel: string // "Format", "Minify", etc.
  stateLabel: string // "Formatted", "Minified", etc.
  displayName: string
}

export function TransformerUi({
  action,
  configs,
  actionLabel,
  stateLabel,
  displayName,
}: TransformerProps) {
  const [input, setInput] = useState('')
  const [output, setOutput] = useState('')
  const [config, setConfig] = useState(getDefaultConfig(configs))
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string>()

  const handleTransform = async () => {
    setLoading(true)
    setError(undefined)

    try {
      const result = await action(input, config)
      setOutput(result)
      toast.success(`${stateLabel} successfully!`)
    } catch (err) {
      setError(err.message)
      toast.error(`Failed to ${actionLabel.toLowerCase()}`)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-4">
      {/* Editors */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <CodeEditor
          label="Input"
          value={input}
          onChange={setInput}
          language={getLanguage(displayName)}
        />
        <CodeEditor
          label="Output"
          value={output}
          readOnly
          language={getLanguage(displayName)}
          error={error}
        />
      </div>

      {/* Configuration + Actions */}
      <div className="flex items-center gap-4 flex-wrap">
        {configs?.map((config) => (
          <ConfigControl
            key={config.id}
            config={config}
            value={config[config.id]}
            onChange={(v) => setConfig({ ...config, [config.id]: v })}
          />
        ))}

        <div className="ml-auto flex gap-2">
          <Button
            onClick={handleTransform}
            disabled={!input || loading}
            className="min-w-32"
          >
            {loading ? <Spinner /> : actionLabel}
          </Button>
          <Button
            variant="outline"
            onClick={() => copyToClipboard(output)}
            disabled={!output}
          >
            <CopyIcon /> Copy
          </Button>
        </div>
      </div>
    </div>
  )
}
```

### CodeMirror Integration

**Editor Component:**

```tsx
// @repo/ui/components/transformer/code-editor.tsx

import { EditorView, basicSetup } from 'codemirror'
import { javascript } from '@codemirror/lang-javascript'
import { json } from '@codemirror/lang-json'
import { css } from '@codemirror/lang-css'
import { html } from '@codemirror/lang-html'
// ... other language modes

interface CodeEditorProps {
  label: string
  value: string
  onChange?: (value: string) => void
  language?: string
  readOnly?: boolean
  error?: string
}

export function CodeEditor({
  label,
  value,
  onChange,
  language,
  readOnly,
  error,
}: CodeEditorProps) {
  const editorRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (!editorRef.current) return

    const extensions = [
      basicSetup,
      getLanguageExtension(language),
      EditorView.theme({}, { dark: isDarkMode }),
      readOnly ? EditorView.editable.of(false) : [],
    ]

    if (onChange) {
      extensions.push(
        EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            onChange(update.state.doc.toString())
          }
        }),
      )
    }

    const view = new EditorView({
      doc: value,
      extensions,
      parent: editorRef.current,
    })

    return () => view.destroy()
  }, [language, readOnly, isDarkMode])

  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      <div ref={editorRef} className="border rounded-lg overflow-hidden" />
      {error && <p className="text-sm text-destructive">{error}</p>}
    </div>
  )
}
```

### Content Sections

**Accordion-based content display:**

```tsx
// @repo/ui/components/content/content-sections.tsx

interface ContentSection {
  heading: string
  content: string // Markdown
}

export function ContentSectionsUi({
  sections,
}: {
  sections: ContentSection[]
}) {
  return (
    <Accordion
      type="multiple"
      defaultValue={[sections[0]?.heading]} // First expanded
      className="space-y-4"
    >
      {sections.map((section) => (
        <AccordionItem key={section.heading} value={section.heading}>
          <AccordionTrigger className="text-lg font-semibold">
            {section.heading}
          </AccordionTrigger>
          <AccordionContent>
            <Markdown>{section.content}</Markdown>
          </AccordionContent>
        </AccordionItem>
      ))}
    </Accordion>
  )
}
```

---

## Development Workflow

### Local Development Setup

#### Prerequisites

- **Node.js:** 20+ LTS (check with `node --version`)
- **pnpm:** 9.x (install with `npm install -g pnpm`)
- **Git:** Latest version
- **Google API Key:** For AI content generation

#### Initial Setup

```bash
# Clone repository
git clone https://github.com/benmvp/tools-app.git
cd tools-app

# Install dependencies
pnpm install

# Set up environment variables
cp .env.example .env.local

# Add your Google API key to .env.local
echo "GOOGLE_API_KEY=your_key_here" >> .env.local

# Start development servers for all apps
pnpm dev

# Or start individual apps
cd apps/codemata && pnpm dev
cd apps/moni && pnpm dev
cd apps/convertly && pnpm dev
```

#### Development Servers

Each app runs on its own port:

- **Codemata:** http://localhost:3001
- **Moni:** http://localhost:3002
- **Convertly:** http://localhost:3003

### Environment Variables

#### Required Variables

```bash
# .env.local (all apps)

# Google AI API Key (required for AI content generation)
GOOGLE_API_KEY=your_google_ai_api_key

# Node Environment (automatically set)
NODE_ENV=development
```

#### Optional Variables

```bash
# For manual revalidation
REVALIDATE_SECRET=your_secret_key_here

# Override AI model (default: gemini-2.0-flash)
AI_MODEL=gemini-2.0-flash

# Enable debug logging
DEBUG=true
```

### Package Scripts

#### Root Level Scripts

```json
{
  "scripts": {
    "dev": "turbo dev",
    "build": "turbo build",
    "start": "turbo start",
    "lint": "turbo lint",
    "type-check": "turbo type-check",
    "test": "turbo test",
    "format": "biome format --write .",
    "format:check": "biome check .",
    "clean": "turbo clean && rm -rf node_modules",
    "regenerate-ai": "node scripts/regenerate-ai.js"
  }
}
```

#### App-Specific Scripts

```json
{
  "scripts": {
    "dev": "next dev --port 3001",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "vitest"
  }
}
```

### Development Commands

#### Start Development

```bash
# All apps simultaneously
pnpm dev

# Single app
pnpm --filter codemata dev
pnpm --filter moni dev
pnpm --filter convertly dev

# With turbo caching
turbo dev --cache-dir=.turbo
```

#### Build for Production

```bash
# All apps
pnpm build

# Single app
pnpm --filter codemata build

# Check build output
ls -la apps/codemata/.next
```

#### Code Quality

```bash
# Lint all code
pnpm lint

# Fix linting issues
pnpm lint --fix

# Format code with Biome
pnpm format

# Check formatting without changes
pnpm format:check

# Type check all packages
pnpm type-check
```

#### AI Content Management

```bash
# Regenerate AI content for all tools
pnpm regenerate-ai

# Regenerate for specific app
pnpm regenerate-ai codemata

# Regenerate for specific tool
pnpm regenerate-ai codemata typescript-formatter

# Clear AI cache (development only)
rm -rf apps/*/app/.ai-cache
```

### Code Organization Patterns

#### File Naming Conventions

- **Components:** PascalCase - `TransformerUi.tsx`
- **Utilities:** kebab-case - `format-code.ts`
- **Types:** PascalCase - `FormatterTypes.ts`
- **Constants:** UPPER_SNAKE_CASE - `FORMATTER_INFO.ts`
- **Hooks:** camelCase with prefix - `useTheme.ts`

#### Import Order

```typescript
// 1. External libraries
import { useState } from 'react'
import { Button } from '@repo/ui/button'

// 2. Internal utilities
import { formatCode } from '@/lib/utils'

// 3. Types
import type { FormatterConfig } from './types'

// 4. Relative imports
import { FormatterInfo } from './info'
```

#### Component Structure

```typescript
// Type definitions first
interface ComponentProps {
  // ...
}

// Component implementation
export function Component({ prop1, prop2 }: ComponentProps) {
  // 1. Hooks
  const [state, setState] = useState()

  // 2. Derived values
  const computed = useMemo(() => /* ... */, [state])

  // 3. Event handlers
  const handleClick = () => {
    // ...
  }

  // 4. Effects
  useEffect(() => {
    // ...
  }, [])

  // 5. Render
  return <div>{/* ... */}</div>
}
```

#### Server Action Pattern

```typescript
// actions.ts
'use server'

import { z } from 'zod'

// Input validation schema
const inputSchema = z.object({
  code: z.string().min(1),
  config: z.object({
    // ...
  }),
})

export async function formatCodeAction(
  input: string,
  config: FormatterConfig,
): Promise<string> {
  // Validate input
  const validated = inputSchema.parse({ code: input, config })

  // Perform transformation
  try {
    const result = await transform(validated.code, validated.config)
    return result
  } catch (error) {
    // Throw with user-friendly message
    throw new Error(formatErrorMessage(error))
  }
}
```

### Git Workflow

#### Branch Strategy

- **main:** Production-ready code
- **feature/\*:** New features (`feature/add-rust-formatter`)
- **fix/\*:** Bug fixes (`fix/json-minifier-error`)
- **chore/\*:** Maintenance (`chore/upgrade-dependencies`)

#### Commit Convention

```bash
# Format: <type>(<scope>): <subject>

# Types: feat, fix, docs, style, refactor, test, chore

# Examples:
git commit -m "feat(codemata): add rust formatter"
git commit -m "fix(ui): resolve dark mode toggle issue"
git commit -m "chore: upgrade Next.js to 15.1"
git commit -m "docs: update README with setup instructions"
```

#### Pull Request Process

1. Create feature branch from `main`
2. Make changes and commit
3. Push to GitHub
4. Open PR with description
5. Wait for checks to pass:
   - **GitHub Actions CI:** Lint, format, type-check, test
   - **Vercel:** Preview deployment build
6. Request review if needed
7. Merge to `main`
8. Vercel auto-deploys to production

### Continuous Integration (GitHub Actions)

#### CI Workflow Overview

GitHub Actions runs automated checks on every push and pull request:

- **Lint:** Code quality checks with Biome
- **Format Check:** Code formatting verification
- **Type Check:** TypeScript compilation
- **Test:** Run unit tests with Vitest

_Note: Build verification is handled by Vercel during deployment._

#### Main CI Workflow

**.github/workflows/ci.yml:**

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  ci:
    name: CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm lint

      - name: Format check
        run: pnpm format:check

      - name: Type check
        run: pnpm type-check

      - name: Test
        run: pnpm test --run
```

#### Test Coverage (Optional Enhancement)

To track test coverage over time, add coverage upload:

**.github/workflows/ci.yml** (add after test step):

```yaml
- name: Test with coverage
  run: pnpm test --run --coverage

- name: Upload coverage to Codecov
  uses: codecov/codecov-action@v4
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  with:
    files: ./coverage/coverage-final.json
    token: ${{ secrets.CODECOV_TOKEN }}
```

_Note: Requires setting up a [Codecov](https://codecov.io) account and adding `CODECOV_TOKEN` secret._

#### Branch Protection Rules

Configure in **Settings → Branches → Branch protection rules** for `main`:

- ✅ Require a pull request before merging
- ✅ Require status checks to pass before merging
  - Select: `CI` (or individual checks: `Lint`, `Test`, etc.)
- ✅ Require branches to be up to date before merging
- ✅ Do not allow bypassing the above settings

_Note: Build verification happens automatically in Vercel preview deployments._

#### CI Performance

The CI workflow typically completes in **2-4 minutes**:

- Install dependencies: ~30s (with cache)
- Lint: ~10s
- Format check: ~5s
- Type check: ~30s
- Tests: ~1-2min

Total: ~2-4 minutes per run

#### Workflow Badges

Add status badges to README.md:

```markdown
[![CI](https://github.com/benmvp/tools-app/actions/workflows/ci.yml/badge.svg)](https://github.com/benmvp/tools-app/actions/workflows/ci.yml)
```

### Debugging

#### Next.js Debugging

```bash
# Enable verbose logging
NODE_OPTIONS='--inspect' pnpm dev

# Debug in VS Code: .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "pnpm dev"
    }
  ]
}
```

#### AI Generation Debugging

```typescript
// In ai.ts, enable debug logging
const DEBUG = process.env.DEBUG === 'true'

if (DEBUG) {
  console.log('AI Request:', { systemMessage, userMessage })
  console.log('AI Response:', response)
}
```

#### Common Issues

**Issue:** AI generation fails during build

```bash
# Check API key
echo $GOOGLE_API_KEY

# Test API key
curl -H "Content-Type: application/json" \
  -d '{"contents":[{"parts":[{"text":"Say hello"}]}]}' \
  "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=$GOOGLE_API_KEY"
```

**Issue:** Port already in use

```bash
# Kill process on port
lsof -ti:3001 | xargs kill -9

# Use different port
pnpm dev -- --port 3010
```

**Issue:** Type errors after updating dependencies

```bash
# Clear cache and reinstall
rm -rf node_modules .next .turbo
pnpm install
pnpm type-check
```

---

## Testing Strategy

### Testing Philosophy

Focus on **unit tests for core transformation logic** to ensure accuracy. E2E and integration tests can be added in future phases.

### Test Stack

- **Framework:** Vitest (fast, Vite-compatible)
- **React Testing:** @testing-library/react
- **Assertions:** Vitest's built-in assertions
- **Coverage:** v8 (built into Vitest)

### Test Structure

```
apps/codemata/
├── app/
│   └── formatters/
│       ├── actions.ts
│       └── actions.test.ts       # Test file alongside source
├── lib/
│   ├── transform.ts
│   └── transform.test.ts
└── vitest.config.ts
```

### Unit Tests for Transformers

**Test Pattern:**

```typescript
// apps/codemata/app/formatters/actions.test.ts

import { describe, it, expect } from 'vitest'
import { formatTypescriptAction } from './actions'

describe('formatTypescriptAction', () => {
  it('formats valid TypeScript code', async () => {
    const input = 'const x=1;const y=2;'
    const config = { indentation: 'two-spaces' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toMatchSnapshot()
    expect(result).toContain('const x = 1')
    expect(result).toContain('const y = 2')
  })

  it('handles invalid TypeScript gracefully', async () => {
    const input = 'const x = {'
    const config = { indentation: 'two-spaces' }

    await expect(formatTypescriptAction(input, config)).rejects.toThrow()
  })

  it('respects indentation config - two spaces', async () => {
    const input = 'function test(){return true}'
    const config = { indentation: 'two-spaces' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toContain('  return') // Two spaces
  })

  it('respects indentation config - four spaces', async () => {
    const input = 'function test(){return true}'
    const config = { indentation: 'four-spaces' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toContain('    return') // Four spaces
  })

  it('respects indentation config - tabs', async () => {
    const input = 'function test(){return true}'
    const config = { indentation: 'tabs' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toContain('\treturn') // Tab character
  })
})
```

### Test Fixtures

```typescript
// apps/codemata/app/formatters/__fixtures__/typescript.ts

export const UNFORMATTED_TS = `
const x=1;const y=2;
function test(){return x+y}
`

export const FORMATTED_TS_TWO_SPACES = `
const x = 1
const y = 2
function test() {
  return x + y
}
`

export const INVALID_TS = `const x = {`
```

**Using Fixtures:**

```typescript
import {
  UNFORMATTED_TS,
  FORMATTED_TS_TWO_SPACES,
} from './__fixtures__/typescript'

it('formats TypeScript correctly', async () => {
  const result = await formatTypescriptAction(UNFORMATTED_TS, {
    indentation: 'two-spaces',
  })

  expect(result.trim()).toBe(FORMATTED_TS_TWO_SPACES.trim())
})
```

### Snapshot Testing

```typescript
it('formats complex TypeScript correctly', async () => {
  const input = fs.readFileSync('__fixtures__/complex.ts', 'utf-8')
  const result = await formatTypescriptAction(input, {
    indentation: 'two-spaces',
  })

  expect(result).toMatchSnapshot()
})
```

### Vitest Configuration

```typescript
// apps/codemata/vitest.config.ts

import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '.next/',
        'vitest.config.ts',
        '**/*.test.ts',
        '**/*.test.tsx',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
})
```

### Running Tests

```bash
# Run all tests
pnpm test

# Run tests in watch mode
pnpm test --watch

# Run tests for specific app
pnpm --filter codemata test

# Run tests with coverage
pnpm test --coverage

# Run specific test file
pnpm test formatters/actions.test.ts

# Update snapshots
pnpm test -u
```

### Test Coverage Goals

- **Transformation Actions:** 100% coverage
- **Utility Functions:** 90%+ coverage
- **Components:** Defer to future phase
- **AI Generation:** Manual testing (expensive to test)

### Manual Testing Checklist

Before each release, manually test:

**Formatters:**

- [ ] Paste unformatted code
- [ ] Select indentation option
- [ ] Verify formatted output
- [ ] Copy to clipboard works
- [ ] Error handling for invalid input
- [ ] Dark mode toggle
- [ ] Mobile responsive layout

**AI Content:**

- [ ] All tool pages load
- [ ] SEO metadata present
- [ ] Content sections render
- [ ] Links to related tools work
- [ ] External resource links work

**Cross-Browser:**

- [ ] Chrome (latest)
- [ ] Firefox (latest)
- [ ] Safari (latest)
- [ ] Mobile Safari (iOS)
- [ ] Mobile Chrome (Android)

---

## Deployment & Infrastructure

### Hosting Platform

**Vercel** - Optimized for Next.js applications

#### Why Vercel?

- Native Next.js support
- Automatic deployments from GitHub
- ISR (Incremental Static Regeneration) support
- Edge Network for global performance
- Free SSL certificates
- Environment variable management
- Preview deployments for PRs

### Deployment Configuration

#### Vercel Projects

Each app is a separate Vercel project:

1. **codemata** → codemata.benmvp.com
2. **moni** → moni.benmvp.com
3. **convertly** → convertly.benmvp.com

#### Project Settings

**Root Directory:** Each project points to its app directory

- Codemata: `apps/codemata`
- Moni: `apps/moni`
- Convertly: `apps/convertly`

**Build Settings:**

```bash
# Build Command
cd ../.. && pnpm install && pnpm --filter codemata build

# Output Directory
.next

# Install Command
pnpm install
```

**Framework Preset:** Next.js

### Domain Configuration

#### DNS Setup

Configure DNS records at your domain provider:

```
# Codemata
CNAME codemata.benmvp.com -> cname.vercel-dns.com

# Moni
CNAME moni.benmvp.com -> cname.vercel-dns.com

# Convertly
CNAME convertly.benmvp.com -> cname.vercel-dns.com
```

#### Vercel Domain Setup

1. Go to Project Settings → Domains
2. Add custom domain
3. Verify ownership
4. SSL automatically provisioned

### Environment Variables

#### Production Environment Variables

Configure in Vercel Dashboard → Settings → Environment Variables:

```bash
# Required for all apps
GOOGLE_API_KEY=your_production_api_key
NODE_ENV=production

# Optional
REVALIDATE_SECRET=your_secret_for_manual_revalidation
AI_MODEL=gemini-2.0-flash
DEBUG=false
```

**Environment Scope:**

- Production: Used for main branch deployments
- Preview: Used for PR preview deployments
- Development: Not used (local only)

### Deployment Workflow

#### Automatic Deployments

```mermaid
Push to GitHub → Vercel detects changes → Build starts
                                            ↓
                                    AI generates content
                                            ↓
                                    Next.js build
                                            ↓
                                    Deploy to production
                                            ↓
                                    Invalidate CDN cache
```

**Branches:**

- `main` branch → Production deployment
- Pull requests → Preview deployments
- Other branches → No automatic deployment

#### Manual Deployment

```bash
# Install Vercel CLI
pnpm add -g vercel

# Login
vercel login

# Deploy to preview
vercel

# Deploy to production
vercel --prod
```

### Build Configuration

#### Next.js Configuration

```typescript
// apps/codemata/next.config.mjs

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Enable ISR
  experimental: {
    // Any experimental features
  },

  // Output: standalone for Node.js runtime
  output: 'standalone',

  // Image optimization
  images: {
    domains: [],
  },

  // Redirects
  async redirects() {
    return []
  },

  // Headers for security
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
        ],
      },
    ]
  },

  // Transpile shared packages
  transpilePackages: ['@repo/ui'],
}

export default nextConfig
```

#### Build Performance

**Build Time Expectations:**

- Without AI generation (cached): 2-3 minutes
- With AI generation: 5-10 minutes (generates content for all tools)
- Large number of tools may increase build time

**Optimization:**

```typescript
// Parallel AI generation
const contentPromises = Object.keys(FORMATTERS_INFO).map((id) =>
  getFormatterContent(id),
)
await Promise.all(contentPromises)
```

### ISR Configuration

#### Page-Level ISR

```typescript
// apps/codemata/app/formatters/[slug]/page.tsx

// Revalidate every 24 hours
export const revalidate = 86400

// Or use time constants
const ONE_DAY = 60 * 60 * 24
export const revalidate = ONE_DAY
```

#### On-Demand Revalidation

```typescript
// apps/codemata/app/api/revalidate/route.ts

import { revalidatePath } from 'next/cache'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const secret = request.nextUrl.searchParams.get('secret')
  const path = request.nextUrl.searchParams.get('path')

  // Validate secret
  if (secret !== process.env.REVALIDATE_SECRET) {
    return NextResponse.json({ message: 'Invalid secret' }, { status: 401 })
  }

  // Validate path
  if (!path) {
    return NextResponse.json({ message: 'Missing path' }, { status: 400 })
  }

  try {
    await revalidatePath(path)
    return NextResponse.json({ revalidated: true, path })
  } catch (err) {
    return NextResponse.json({ message: 'Error revalidating' }, { status: 500 })
  }
}
```

**Trigger Revalidation:**

```bash
curl "https://codemata.benmvp.com/api/revalidate?path=/typescript-formatter&secret=YOUR_SECRET"
```

### Monitoring & Analytics

#### Future: Google Analytics

When ready to add analytics:

```typescript
// app/layout.tsx
import Script from 'next/script'

export default function RootLayout({ children }) {
  return (
    <html>
      <head>
        {process.env.NODE_ENV === 'production' && (
          <>
            <Script
              src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_ID}`}
              strategy="afterInteractive"
            />
            <Script id="google-analytics" strategy="afterInteractive">
              {`
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', '${process.env.NEXT_PUBLIC_GA_ID}');
              `}
            </Script>
          </>
        )}
      </head>
      <body>{children}</body>
    </html>
  )
}
```

#### Future: Google Ads

```typescript
// components/ad-banner.tsx
export function AdBanner({ slot }: { slot: string }) {
  useEffect(() => {
    try {
      ;(window.adsbygoogle = window.adsbygoogle || []).push({})
    } catch (err) {
      console.error('Ad error:', err)
    }
  }, [])

  return (
    <ins
      className="adsbygoogle"
      style={{ display: 'block' }}
      data-ad-client={process.env.NEXT_PUBLIC_ADSENSE_ID}
      data-ad-slot={slot}
      data-ad-format="auto"
      data-full-width-responsive="true"
    />
  )
}
```

### Performance Optimization

#### Caching Strategy

```typescript
// Static assets: Cache for 1 year
// API routes: No cache
// Pages: ISR (24 hours)

// next.config.mjs
const nextConfig = {
  async headers() {
    return [
      {
        source: '/static/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ]
  },
}
```

#### Image Optimization

```typescript
// Use Next.js Image component
import Image from 'next/image'

<Image
  src="/logo.svg"
  alt="Logo"
  width={200}
  height={50}
  priority // For above-fold images
/>
```

#### Code Splitting

```typescript
// Lazy load heavy components
const CodeEditor = dynamic(() => import('./code-editor'), {
  loading: () => <Skeleton />,
  ssr: false, // Client-side only if needed
})
```

### Security

#### Environment Variables

- Never commit `.env.local` to git
- Use Vercel's environment variable UI
- Rotate API keys periodically

#### Content Security Policy

```typescript
// next.config.mjs
const nextConfig = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'Content-Security-Policy',
            value: [
              "default-src 'self'",
              "script-src 'self' 'unsafe-eval' 'unsafe-inline'",
              "style-src 'self' 'unsafe-inline'",
              "img-src 'self' data: https:",
              'font-src "self" data:',
            ].join('; '),
          },
        ],
      },
    ]
  },
}
```

### Backup & Recovery

#### Code Backup

- **GitHub:** Primary source of truth
- **Vercel:** Automatic deployments history
- **Tags:** Git tags for release versions

```bash
# Tag releases
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0
```

#### Rollback Strategy

```bash
# Revert to previous deployment in Vercel
# Via Vercel Dashboard → Deployments → Previous → Promote to Production

# Or revert git commit
git revert HEAD
git push origin main
```

---

## Implementation Plan

### Overview

The implementation follows a **pragmatic, YAGNI-driven approach** that prioritizes shipping working software over building infrastructure. The plan focuses on building Codemata first, launching it publicly, then expanding it with additional tools before building the other apps. Shared packages are extracted **only when duplication becomes painful**, not upfront.

**Key Principles:**
- Build one working tool ASAP
- Deploy early and often
- Launch publicly after AI content integration
- Expand Codemata based on traffic/analytics data
- Extract shared code only when proven necessary
- Build Convertly and Moni last, once Codemata is generating revenue

**Effort Estimates:** Tasks are sized as S (Small), M (Medium), L (Large), or XL (Extra Large)

---

### Phase 1: Codemata MVP - Single Formatter (Size: S)

**Goal:** Get one working formatter deployed to production ASAP

#### Tasks

**1.1 Basic Next.js App**

- [x] Create `apps/codemata/` with Next.js 15
- [x] Configure Tailwind CSS (Codemata theme directly in app)
- [x] Install shadcn/ui components (directly in app)
- [x] Set up basic TypeScript config

**1.2 Simple Layout**

- [x] Create root layout with basic header/footer (in app)
- [x] Add dark mode toggle (use next-themes)
- [x] Basic responsive design

**1.3 TypeScript Formatter - First Tool**

- [x] Create `app/formatters/typescript-formatter/page.tsx`
- [x] Build dual CodeMirror editor layout (in page)
- [x] Implement `formatTypescriptAction` with Prettier
- [x] Add indentation config dropdown
- [x] Add copy button
- [x] Basic error handling

**1.4 Home Page**

- [x] Simple hero section
- [x] Link to TypeScript formatter
- [x] Basic styling

**1.5 Deploy**

- [x] Set up Vercel project
- [x] Deploy to codemata.benmvp.com
- [x] Test in production

**Deliverable:** Working Codemata app with ONE formatter in production 🚀

---

### Phase 2: Complete Formatters (Size: M)

**Goal:** Add all 8 formatters using the pattern from Phase 1

#### Tasks

**2.1 Add Remaining Formatters**

- [x] JSON formatter (`/formatters/json-formatter/`)
- [x] CSS formatter (`/formatters/css-formatter/`)
- [x] HTML formatter (`/formatters/html-formatter/`)
- [x] GraphQL formatter (`/formatters/graphql-formatter/`)
- [x] Markdown formatter (`/formatters/markdown-formatter/`)
- [x] XML formatter (`/formatters/xml-formatter/`)
- [x] YAML formatter (`/formatters/yaml-formatter/`)

**2.2 Refactor if Needed**

- [x] Extract common transformer component if duplication is annoying
- [x] Extract shared types if needed
- [x] Keep everything in Codemata app for now

**2.3 Home Page Update**

- [x] Add "Formatters" section with tool grid
- [x] Add icons and descriptions
- [x] Make it look nice

**2.4 Testing**

- [x] Set up Vitest
- [x] Write tests for each formatter action
- [x] Test manually

**Deliverable:** Codemata with all 8 formatters working

---

### Phase 3: Add Minifiers (Size: M)

**Goal:** Add all 6 minifiers

#### Tasks

**3.1 Create Minifier Pages**

- [x] TypeScript minifier (`/minifiers/typescript-minifier/`)
- [x] JSON minifier (`/minifiers/json-minifier/`)
- [x] CSS minifier (`/minifiers/css-minifier/`)
- [x] HTML minifier (`/minifiers/html-minifier/`)
- [x] SVG minifier (`/minifiers/svg-minifier/`)
- [x] XML minifier (`/minifiers/xml-minifier/`)

**3.2 Update Home Page**

- [x] Add "Minifiers" section
- [x] Update navigation

**3.3 Polish**

- [x] Improve error messages
- [x] Add loading states
- [x] Mobile testing
- [x] Dark mode testing

**Deliverable:** Complete Codemata with 14 tools (8 formatters + 6 minifiers) ✅

---

### Phase 4: AI Content Integration (Size: M)

**Goal:** Transform tools into comprehensive educational resources with AI-generated content that drives organic traffic, increases engagement, and establishes authority—while keeping builds fast and costs optimized through on-demand generation.

**Strategy Summary:**
- **Content:** Full comprehensive content (8 sections + tips + recommendations)
- **Generation:** On-demand with ISR (first request loads longer, then cached)
- **Refresh:** Automatic 24-hour revalidation
- **Errors:** Graceful degradation (tool always works)
- **Enhancements:** Contextual tips + AI-powered tool recommendations

#### Tasks

**4.1 Infrastructure Setup**

- [x] Install Google AI SDK (`@google/generative-ai`)
- [x] Install Zod for schema validation
- [x] Install Markdown rendering library:
  - [x] `react-markdown` - Main renderer
  - [x] `remark-gfm` - GitHub Flavored Markdown support
  - [x] `react-syntax-highlighter` - Code block syntax highlighting
- [x] Set up `GOOGLE_API_KEY` environment variable
- [x] Create `lib/ai/client.ts` - Gemini client initialization
- [x] Create `lib/ai/cache.ts` - In-memory request cache (prevent duplicate calls)
- [x] Add retry logic with exponential backoff for API failures

**4.2 Content Schema & Types**

- [x] Define comprehensive Zod schema in `lib/ai/schema.ts`:
  - [x] SEO metadata (title, description, keywords)
  - [x] OpenGraph metadata (title, description, type)
  - [x] 8 content sections (intro, features, rationale, purpose, integrate, faq, recommendations, resources)
  - [x] Tips array (3-5 tips/facts/best practices)
  - [x] Recommendations (related tool suggestions)
- [x] Export TypeScript types from schema
- [x] Document schema structure in comments

**4.3 Prompt Engineering**

- [x] Create system prompt template in `lib/ai/prompts.ts`:
  - [x] Define tone and style (friendly, educational, SEO-optimized)
  - [x] Specify output format for each section
  - [x] Include markdown formatting rules
  - [x] Set character/word limits per section
- [x] Create dynamic user prompt builder:
  - [x] Include tool metadata (name, description, languages)
  - [x] Include list of all available tools (for recommendations)
  - [x] Include tool category context
- [x] Write separate prompt templates for:
  - [x] Formatters
  - [x] Minifiers
  - [ ] Future: Encoders, Validators, Converters

**4.4 Content Generation Logic**

- [x] Create `lib/ai/generate.ts` with core functions:
  - [x] `generateToolContent(toolId, toolMetadata)` - Main generation function
  - [x] `getCachedContent(cacheKey)` - Check in-memory cache
  - [x] `setCachedContent(cacheKey, content)` - Store in cache
  - [x] `validateContent(response)` - Zod validation
- [x] Implement error handling:
  - [x] Return `undefined` on API failure (graceful degradation)
  - [x] Log errors for monitoring
  - [x] Retry failed requests (max 3 attempts)
- [x] Add ISR configuration (`revalidate = 86400` - 24 hours)
- [x] Test generation with 2-3 tools initially
- [x] Add `SKIP_AI_GENERATION` env var for local dev
- [x] Implement React cache() for request deduplication
- [x] Configure production pre-rendering (`VERCEL_ENV=production`)

**4.5 Tool Recommendations**

- [x] Create AI-powered recommendations in generation logic
- [x] Parse and validate tool IDs from AI response
- [x] Fallback: Return empty array if AI fails (no recommendations shown)
- [x] Validate tool IDs exist in current tool list
- [x] Add recommendation display component (`<RecommendedTools>`)
- [x] Link to recommended tools with icons
- [x] Hide entire section if no recommendations available
- [x] Limit to max 3 recommendations for better layout

**4.6 Contextual Tips System**

- [x] Generate 3-5 tips per tool in content generation
- [x] Categorize as tip/fact/bestPractice
- [x] Keep each tip under 150 characters
- [x] Create `<TipCard>` component:
  - [x] Floating card style with icon (lightbulb for tips, star for facts, checkmark for best practices)
  - [x] Visually distinct from content sections (colored border, background)
  - [x] Style by type (different colors: blue for tips, purple for facts, green for best practices)
  - [x] Interspersed between content sections (breaks up long text)
  - [x] Responsive padding and margins
- [x] Test tips display on mobile
- [x] Ensure tips don't disrupt reading flow

**4.7 Content Display Components**

- [x] Create `<ContentSection>` component:
  - [x] Props: heading, content (markdown)
  - [x] Use `react-markdown` with `remark-gfm` for rendering
  - [x] Use `react-syntax-highlighter` for code blocks
  - [x] All sections expanded by default (no collapsing)
  - [x] Responsive design with proper typography
  - [x] Semantic HTML (section, h2, etc.)
- [x] Create content display with consistent spacing
- [x] Section ordering: How to Use → Features → Rationale → Purpose → Integration → FAQ → Recommendations → Resources
- [x] Intersperse tip cards between sections (sequential distribution)
- [x] Create `<TipCard>` component (floating cards):
  - [x] Props: type ('tip' | 'fact' | 'bestPractice'), content
  - [x] Icon based on type (lucide-react icons)
  - [x] Colored border and background based on type
  - [x] Margin top/bottom for breathing room
  - [x] Responsive width (full width on mobile)
- [x] Create `<RecommendedTools>` component:
  - [x] Display tool cards with links
  - [x] Show tool icon and brief description
  - [x] Grid layout (responsive: 1 col mobile, 3 cols desktop)
  - [x] Fallback: hide section if no recommendations

**4.8 Page Integration**

- [x] Update `app/formatters/[slug]/page.tsx`:
  - [x] Page structure with Suspense for loading states
  - [x] Call AI generation with React cache() deduplication
  - [x] Intro paragraph with separate Suspense boundary
  - [x] Tool functionality (always available)
  - [x] Content sections with tips interspersed
  - [x] Gracefully hide content sections if generation fails
  - [x] Ensure proper TypeScript typing for all props
- [x] Update `app/minifiers/[slug]/page.tsx` (same pattern)
- [x] Ensure tool functionality works WITHOUT AI content
- [x] Test page with and without AI content
- [x] Verify tip cards render properly between sections
- [x] Add `<AIContentSkeleton>` loading component
- [x] Fix newline processing in AI content

**4.9 Metadata & SEO**

- [x] Update `generateMetadata()` in page components:
  - [x] Use AI-generated SEO metadata
  - [x] Set title, description, keywords
  - [x] Add OpenGraph tags:
    - [x] `og:title`
    - [x] `og:description`
    - [x] `og:type` (website)
    - [x] `og:url`
    - [ ] `og:image` (app logo/screenshot) - Future: Phase 5
  - [x] Add Twitter Card tags:
    - [x] `twitter:card` (summary_large_image)
    - [x] `twitter:title`
    - [x] `twitter:description`
    - [ ] `twitter:image` - Future: Phase 5
  - [x] Fallback to static metadata if AI fails
- [ ] Test social sharing preview (Twitter, LinkedIn, Slack) - Phase 5

**4.10 Build Optimization**

- [x] Configure ISR with 24-hour revalidation
- [x] Implement React cache() for request deduplication
- [x] Production pre-rendering via `VERCEL_ENV=production`
- [x] Skip AI in preview builds and local dev
- [x] `SKIP_AI_GENERATION` env var for local development
- [x] Monitor API usage with console logging
- [ ] Set up alerts for high usage - Future: Phase 5

**4.11 Manual Regeneration**

- [ ] Create `/api/revalidate` endpoint:
  - [ ] Accept tool slug or "all"
  - [ ] Trigger ISR revalidation
  - [ ] Require secret token for security
- [ ] Create `scripts/regenerate-ai.js`:
  - [ ] CLI script to regenerate content
  - [ ] Options: specific tool, category, or all
  - [ ] Progress indicator
  - [ ] Error reporting
- [ ] Document regeneration process in README

**4.12 Testing & Quality Assurance**

- [x] Test content generation for sample tools
- [x] Verify Zod validation catches malformed responses
- [x] Test error handling (simulate API failures)
- [x] Verify ISR caching behavior
- [x] Test on-demand generation (first request)
- [x] Verify graceful degradation (tool works without AI)
- [x] Verify SEO metadata in page source
- [x] Test Suspense loading states
- [x] Test production pre-rendering
- [x] Test preview build on-demand generation
- [x] Test local dev with SKIP_AI_GENERATION
- [ ] Test social media preview cards (Twitter, LinkedIn, Slack) - Phase 5
- [x] Mobile testing for content display and tip cards - Phase 5
- [x] Accessibility audit for content sections - Phase 5
- [ ] Deploy and monitor content quality via spot checks - Phase 5
- [ ] Use manual regeneration script if issues found in production - After 4.11

**Status:** ✅ **COMPLETED** (Core implementation done, manual regeneration tools and polish in Phase 5)

**Deliverable:** Codemata with full AI content, SEO-optimized metadata, production pre-rendering, and developer-friendly local workflow

---

### Phase 5: Polish & Public Launch (Size: M)

**Goal:** Production-ready public launch of Codemata

#### Tasks

**5.1 SEO Foundation**

- [x] Add `robots.txt` and `sitemap.xml`
- [x] Add base metadata to root layout (title template, description, OpenGraph, Twitter Cards, robots)
- [x] Add page-level metadata (home, category pages, tool pages)
- [x] Add JSON-LD structured data to all tool pages
- [x] Add canonical URLs to all pages
- [x] Create metadata verification script (`scripts/verify-metadata.ts`)
- [x] Create centralized site configuration (`lib/site-config.ts`)
- [x] Create `getAppUrl()` helper for environment-aware URLs (localhost vs production)
- [x] Create `getToolUrl()` helper for tool URL construction
- [x] Create `JsonLd` component to safely handle JSON-LD structured data
- [x] All metadata validation passing (100% pass rate)
- [x] Submit to Google Search Console & add `sitemap.xml`
- [ ] Monitor search rankings and traffic

**5.2 Performance Optimization**

- [x] Lighthouse audits
- [ ] Bundle size optimization
- [ ] ISR testing

**5.3 Dynamic OpenGraph Images**

- [x] Install `@vercel/og` package
- [x] Create `/api/og/route.tsx` endpoint:
  - [x] Generate OG image dynamically using Vercel's edge runtime
  - [x] Design card template:
    - [x] Codemata logo (top left)
    - [x] Tool/page title (large, 110px font): e.g., "JSON Formatter", "14 Free Developer Tools"
    - [x] Description text (36px font, supporting context)
    - [x] Tagline: "Codemata — Developer Tools" (bottom)
    - [x] Gradient background (blue-100 to white) with decorative elements
    - [x] Decorative circles with subtle opacity for visual depth
  - [x] Inter font loaded automatically by Next.js OG
  - [x] Return PNG image (1200x630px for optimal social sharing)
  - [x] Cache images at edge (`max-age=31536000, stale-while-revalidate=86400`)
- [x] Update `generateMetadata()` in all pages (17 total):
  - [x] Home page (`/`)
  - [x] Formatters category page (`/formatters`)
  - [x] Minifiers category page (`/minifiers`)
  - [x] 8 formatter tool pages
  - [x] 6 minifier tool pages
  - [x] Set `openGraph.images` with title+description parameters
  - [x] Set `twitter:image` to same URL
- [x] Implement cache busting strategy:
  - [x] OG_IMAGE_VERSION constant for manual design changes
  - [x] Count-based URLs for home/category pages (auto-bust when tools added)
- [x] Test OG images in social media debuggers:
  - [ ] [Twitter Card Validator](https://cards-dev.twitter.com/validator)
  - [ ] [LinkedIn Post Inspector](https://www.linkedin.com/post-inspector/)
  - [ ] [Facebook Sharing Debugger](https://developers.facebook.com/tools/debug/)
  - [x] Slack unfurl preview
- [ ] Ensure images render correctly on all platforms
- [ ] Verify edge caching is working (check response headers in production)

**Resources:**
- Vercel OG Image Generation: https://vercel.com/docs/functions/edge-functions/og-image-generation
- @vercel/og package: https://www.npmjs.com/package/@vercel/og
- Example template: Card with logo + tool name + icon + tagline

**5.4 Category Back Navigation & Navigation Improvements**

- [x] Create `<CategoryBackLink>` component:
  - [x] Pill/badge style with rounded corners
  - [x] ArrowLeft icon from lucide-react
  - [x] Background: `bg-muted` with hover effect
  - [x] Text: `text-sm font-medium text-muted-foreground`
  - [x] Hover: scale slightly + darken background
  - [x] Props: `href` and `label`
  - [x] CSS `order-[-1]` to display above H1 while maintaining semantic DOM order
- [x] Add back link to formatter tool pages:
  - [x] Shows "← Formatters" above page title
  - [x] Links to `/formatters` category page
  - [x] Positioned with `mb-6` spacing
- [x] Add back link to minifier tool pages:
  - [x] Shows "← Minifiers" above page title
  - [x] Links to `/minifiers` category page
  - [x] Positioned with `mb-6` spacing
- [x] Design decisions:
  - [x] No "Home" link (logo/wordmark serves that purpose)
  - [x] No current page in navigation (H1 title shows that)
  - [x] Single category link acts as "back to category" navigation
  - [x] Floating above title, not traditional breadcrumbs
- [x] SEO & Accessibility improvements:
  - [x] H1 title comes first in DOM (semantic order)
  - [x] CategoryBackLink comes after H1, uses flexbox `order-[-1]` to display above
  - [x] Main content comes before Sidebar in DOM
  - [x] Visual layout maintained with CSS positioning
- [x] Test navigation on all 14 tool pages (8 formatters + 6 minifiers)
- [x] Verify hover states and accessibility
- [x] Refactor navigation components to eliminate duplication:
  - [x] Extract `<NavigationList>` component shared by Sidebar and MobileNav
  - [x] Data-driven categories configuration (easy to add new categories)
  - [x] Category headers clickable (link to `/formatters`, `/minifiers` pages)
  - [x] Eliminated ~160 lines of duplicate code
- [x] Fix mobile layout issues:
  - [x] MobileHeader positioning (fixed instead of sticky)
  - [x] Add padding-top to prevent content from being hidden under fixed header
  - [x] Optimize vertical spacing on mobile (reduce hero padding)

**Status:** ✅ **COMPLETED**

**5.5 Category Page Content Enhancements**

**Decision:** Skip AI-generated category content in favor of manual, focused content. Category pages serve primarily as navigation hubs, and tool pages already provide comprehensive educational content. Manual approach is simpler, faster, and more maintainable.

- [x] Add richer hero copy to category pages:
  - [x] `/formatters` page - 2 educational paragraphs below hero
  - [x] `/minifiers` page - 2 educational paragraphs below hero
  - [x] Explain what the category does and its benefits
  - [x] Positioned after tool grid (lower priority than tool discovery)
  - [x] Left-aligned for better readability
  - [x] Responsive spacing (reduced padding on mobile)
- [x] Optimize mobile viewing experience:
  - [x] Reduce vertical padding on hero sections (mobile: py-8, desktop: py-12/py-20)
  - [x] Reduce container padding (mobile: py-6, desktop: py-12)
  - [x] Save ~64px of vertical space on mobile screens

**Future Consideration:** If catalog grows to 50+ tools per category or SEO data shows opportunity for category-level keywords, revisit AI-generated content with FAQ sections and comparison tables.

**Status:** ✅ **COMPLETED**

**5.6 Cross-browser Testing**

- [ ] Chrome, Firefox, Safari
- [ ] Mobile testing

**5.7 Documentation**

- [x] Update README
- [x] Document the setup process

**5.8 PWA Testing**

- [x] Add favicon (multiple sizes for different platforms)
- [x] Add PWA support (manifest.json, service worker, icons)
- [x] Test app installation on mobile devices

**5.9 Command Menu Search (Cmd+K)**

**Goal:** Enable fast, keyboard-first tool discovery as the tool catalog grows

**UI/UX Pattern:**

- Cmd+K keyboard shortcut (Ctrl+K on Windows) opens search modal
- Modal with auto-focused search input and fuzzy matching
- Results grouped by category (Formatters, Minifiers, Encoders, etc.)
- Keyboard navigation: arrow keys to select, Enter to navigate, Esc to close
- Search icon in header opens same modal (mobile-friendly)
- Empty state shows recent tools (stored in localStorage)
- Subtle hints throughout app: "Press ⌘K to search"

**Technical Approach:**

- Use `cmdk` library (by Radix team) for command menu with built-in fuzzy search
- Client-side search (instant results, no API latency)
- Search index generated from tool metadata at build time
- Index includes: tool name, category, keywords, description
- Modal managed with shadcn/ui Dialog component
- Global keyboard listener for Cmd+K shortcut
- Navigation via Next.js router on selection

**Search Features by Phase:**

*MVP (Phase 5.9):*
- Fuzzy text matching on tool names
- Category grouping in results
- Keyboard navigation
- Basic keyword matching (e.g., "js" finds JavaScript tools)

*Enhanced (Future):*
- Filter by category ("formatters", "minifiers")
- Filter by language ("javascript tools", "json tools")
- Recent searches (localStorage)
- Analytics tracking for popular searches
- "Did you mean?" suggestions

*Advanced (Future):*
- Search within AI-generated content
- Popular tools highlighted
- Search shortcuts ("f" = jump to formatters, "m" = minifiers)
- Command palette for app actions (theme toggle, etc.)

**Tasks:**

- [x] Install `cmdk` package from npm
- [x] Install shadcn/ui command component
- [x] Add `keywords` field to Tool type
- [x] Add keywords to all 14 tools (8 formatters + 6 minifiers)
- [x] Generate search index from tool metadata (`lib/search-index.ts`)
- [x] Create recent tools storage utility (`lib/recent-tools.ts`)
- [x] Create `<CommandMenu>` component using cmdk:
  - [x] Cmd+K/Ctrl+K keyboard shortcut listener
  - [x] Fuzzy search across tool names and keywords
  - [x] Category-based result grouping (Formatters, Minifiers)
  - [x] Keyboard navigation support (arrows, Enter, Esc)
  - [x] Recent tools in empty state (localStorage)
  - [x] Popular tools fallback when no recent history
- [x] Add search triggers:
  - [x] Desktop: Fake search box in sidebar with ⌘K hint
  - [x] Mobile: Icon button in header
  - [x] Both open command menu on click
- [x] Add `<VisitTracker>` component to track tool visits
- [x] Add visit tracking to all formatter pages
- [x] Add visit tracking to all minifier pages
- [x] Add keyboard shortcut hint to Footer ("Press ⌘K to search")
- [x] Customize CommandDialog for mobile (90-95% width)
- [x] Test across browsers and devices
- [x] Verify accessibility (keyboard-only navigation works)
- [ ] Track search analytics (optional, Phase 7)

**Resources:**
- cmdk library: https://cmdk.paco.me/
- shadcn/ui command component: https://ui.shadcn.com/docs/components/command

**Status:** ✅ **COMPLETED**

**Deliverable:** Codemata with fast, keyboard-first tool discovery via Cmd+K search 🚀

---

### Phase 6: Additional Formatters (Size: S) ✅ **COMPLETED**

**Goal:** Add high-traffic formatter discovered after initial launch

#### Tasks

**6.1 SQL Formatter**

- [x] Add SQL formatter page (`/formatters/sql-formatter/`)
- [x] Implement `formatSqlAction` using `sql-formatter`
- [x] Support multiple SQL dialects (MySQL, PostgreSQL, SQLite, etc.) - 17 dialects total
- [x] Add configuration options (indentation, keyword case, etc.)
- [x] Write tests
- [x] Type system refactoring (FormatterTool, MinifierTool specialized types)

**6.2 AI Content & Deploy**

- [x] Generate AI content for SQL formatter
- [x] Update home page with new tool
- [x] Deploy to production

**Deliverable:** ✅ Codemata with 15 tools (9 formatters + 6 minifiers)

**Status:** ✅ **COMPLETED** - SQL Formatter with 17 dialect support (PostgreSQL, MySQL, MariaDB, SQLite, SQL Server/T-SQL, BigQuery, DB2, DB2i, Hive, N1QL, PL/SQL, Redshift, SingleStoreDB, Snowflake, Spark, Standard SQL, Trino), configuration options for keyword case and indentation, full test coverage, and type system improvements

---

### Phase 7: Quality, Monitoring & Monetization (Size: M)

**Goal:** Establish quality gates, analytics, and revenue streams

#### Tasks

**7.1 Analytics Setup**

- [x] Set up Google Analytics 5
- [x] Add tracking to all pages
- [ ] Track tool usage events

**7.2 Automated Testing & CI**

- [x] Install Playwright for E2E testing (Firefox browser)
- [x] Configure Playwright:
  - [x] Headed mode for local dev (with `--ui` debug mode)
  - [x] Headless mode for CI
  - [x] Test against production build (`next build` + `next start`)
  - [x] Tests in `apps/codemata/tests/e2e/`
- [x] Write E2E tests for critical user flows:
  - [x] **Core Tool Functionality:**
    - [x] Paste code → format → copy result (formatters)
    - [x] Paste code → minify → copy result (minifiers)
    - [x] Configuration changes (indentation options)
    - [x] Error handling (invalid syntax, malformed code)
  - [x] **Navigation & Discovery:**
    - [x] Navigation between tools via sidebar
    - [x] Category landing pages (`/formatters`, `/minifiers`)
    - [x] Category back links
    - [x] Command Menu (⌘K) search and navigation
    - [x] Recent tools tracking and display
  - [x] **UI Features:**
    - [x] Dark mode toggle persistence
    - [x] Mobile responsive behavior (sidebar drawer)
    - [x] Scroll-to-top FAB on long pages
  - [x] **SEO & Metadata:**
    - [x] Verify page titles and descriptions
    - [x] OpenGraph image URLs load correctly
    - [x] Canonical URLs are correct
- [x] Install axe-core for accessibility testing
- [x] Write accessibility tests (comprehensive - all 17 pages):
  - [x] **WCAG AA Compliance:**
    - [x] Home page
    - [x] Category pages (formatters, minifiers)
    - [x] All 8 formatter tool pages (9 formatters including SQL)
    - [x] All 6 minifier tool pages
  - [x] **Keyboard Navigation:**
    - [x] Tab order follows logical flow
    - [x] Enter activates buttons/links
    - [x] Escape closes dialogs (command menu)
    - [x] Focus visible on all interactive elements
    - [x] CodeMirror editor keyboard accessible
  - [x] **Screen Reader Compatibility:**
    - [x] ARIA labels on all controls
    - [x] Proper ARIA roles (dialog, menu, button)
    - [x] Tool configuration dropdowns/selects labeled
    - [x] Dynamic content announcements
    - [x] Heading hierarchy (h1 → h2 → h3)
  - [x] **Visual Accessibility:**
    - [x] Color contrast validation (WCAG AA 4.5:1)
    - [x] Focus indicators meet contrast requirements
    - [x] No color-only information
  - [x] **Component-Specific:**
    - [x] Command menu focus trap
    - [x] Mobile navigation accessible
    - [x] Collapsible AI content sections keyboard accessible
- [x] Set up Lighthouse CI (blocking):
  - [x] Performance score ≥ 90
  - [x] Accessibility score ≥ 93
  - [x] Best Practices score ≥ 90
  - [x] SEO score ≥ 95
  - [x] Fail builds if scores drop below thresholds
  - [x] Test representative pages (home, 2 categories, 2 tools per category = 7 pages)
- [x] Update `.github/workflows/ci.yml` with hybrid job strategy:
  - [x] **Stage 1 (Parallel):** `type-check`, `lint`, `format` (fast quality checks)
  - [x] **Stage 2 (Sequential):** `build` (uploads artifact) + `test` (unit tests)
  - [x] **Stage 3 (Parallel):** `e2e`, `lighthouse` (download artifact, comprehensive validation)
  - [x] Run on all PRs and main branch pushes
  - [x] Set up GitHub branch protection requiring all checks to pass
- [x] Document testing approach:
  - [x] Add testing section to README with local commands
  - [x] Document how to run Playwright UI mode
  - [x] Explain CI workflow stages
  - [x] Add troubleshooting guide for common test failures

**7.3 Monetization**

- [x] Set up Google AdSense account
- [ ] Add ads below tools
- [ ] Add ads in content sections
- [ ] Test ad placement and performance
- [ ] A/B test different placements
- [ ] Optimize based on revenue data

**7.4 Monitoring & Data Collection**

- [ ] Monitor traffic for 2-4 weeks
- [ ] Identify popular tools
- [ ] Analyze user behavior
- [ ] Identify optimization opportunities
- [ ] Monitor test results and fix failures

**Deliverable:** Revenue-generating Codemata with comprehensive quality gates and performance tracking

---

### Phase 8: Expand Codemata - Encoders/Decoders (Size: L) ✅

**Goal:** Add high-traffic encoder/decoder tools

#### Tools to Build

- [x] JWT Decoder (very high traffic potential) ✅
- [x] Base64 Encoder/Decoder ✅
- [x] URL Encoder/Decoder ✅
- [x] HTML Entity Encoder/Decoder ✅
- [x] JS String Encoder/Decoder ✅

#### Tasks

**8.1 Implement Tools** ✅

- [x] Create encoder/decoder pages ✅
- [x] Implement server actions for each ✅
- [x] Build appropriate UI (TransformerEncoder component with bidirectional buttons) ✅
- [x] Write tests (unit tests, e2e, a11y & lighthouse tests) ✅
  - [x] Unit tests: 18 tests for all encoder actions ✅
  - [x] E2E tests: 26 tests for encode/decode/round-trip/copy/disabled states ✅
  - [x] A11y compliance: 5 tests (WCAG 2.0/2.1 Level AA) ✅
  - [x] Keyboard navigation: 5 tests for encoder-specific interactions ✅
  - [x] Lighthouse tests: Performance/accessibility benchmarks ✅

**8.2 AI Content & SEO** ✅

- [x] Generate AI content for each tool ✅
- [x] Optimize for high-traffic keywords ✅
- [x] Update sitemap ✅
- [x] Fix AI content list formatting (added explicit markdown formatting rules) ✅

**8.3 UX Improvements** ✅

- [x] Auto-scroll navigation to selected tool ✅
- [x] Bidirectional encoder UI with mode buttons ✅

**8.4 Deploy & Monitor**

- [ ] Deploy to production ⏳ (ready for deployment)
- [ ] Monitor analytics for these tools
- [ ] Track revenue impact

**Deliverable:** 5 additional encoders/decoders tools

---

### Phase 9: Expand Codemata - Validators/Checkers (Size: L)

**Goal:** Add validation and checking tools

**Status:** 🚧 In Progress (Phase 9.1-9.4 complete - JSON & HTML validators live)

#### Tools to Build

- [x] JSON Validator (with schema support)
- [x] HTML Validator
- [ ] XML Validator
- [ ] CSS Validator
- [ ] Regex Tester
- [ ] URL Validator
- [ ] (More validators as prioritized by analytics)

#### Tasks

**9.1 Foundation & Infrastructure** ✅ **COMPLETE**

- [x] Create validator pages structure
- [x] Build shared validation utilities
- [x] Build error display UI components
- [x] Build category page
- [x] Add to navigation UI
- [x] Set up with "Coming Soon" badges

**9.2 Implement Validators** 🚧 In Progress

- [x] JSON Validator
- [x] HTML Validator (with html-validate, a11y checks, 65/35 layout)
- [ ] Regex Tester
- [ ] CSS Validator
- [ ] XML Validator

**9.3 AI Content & SEO**

- [ ] Generate AI content for each tool
- [ ] Update sitemap

**9.4 Deploy & Monitor**

- [ ] Deploy to production
- [ ] Monitor analytics
- [ ] Track revenue impact

**Deliverable:** Codemata with comprehensive validation tools

---

### Phase 10+: Continue Codemata Expansion (Size: Varies)

**Goal:** Add remaining tool categories based on data

#### Tool Categories (in priority order)

1. **Git/DevOps** (Size: S) - HIGHEST PRIORITY
   - .gitignore Generator (massive traffic), GitHub Markdown Preview, Dockerfile Linter

2. **CSS Generators** (Size: M) - VERY HIGH ENGAGEMENT
   - Box Shadow Generator, Border Radius, Flexbox Generator, CSS Grid Generator

3. **Image Tools** (Size: L) - HIGH SEO VALUE
   - Image Compressor/Optimizer, Format Converter, Resizer, Favicon Generator

4. **Converters** (Size: L)
   - CRON Generator/Parser (very high traffic), HTML ↔ Markdown, XML ↔ JSON, CSV ↔ JSON, YAML ↔ JSON, Timestamp ↔ Date, SVG/Image to Data URI

5. **Generators** (Size: M)
   - Fake Data Generator (high value), Hash, UUID, QR codes, Meta tags, Passwords, Lorem Ipsum, JSON Schema to Sample, Badge Generator

6. **Text Tools** (Size: M)
   - String Diff, JSONPath Tester, XPath Tester, Case converter, Text analyzer, String reverser, Line sort/dedup, ASCII Art

7. **Security/Crypto** (Size: M)
   - Password Strength Checker, Certificate Decoder, Public Key Converter

8. **API/HTTP Reference** (Size: S)
   - HTTP Status Reference, MIME Type Lookup, User Agent Parser, Query String Builder

9. **Viewers** (Size: L)
   - SVG Viewer, Markdown Preview, Diff Tool, Page Source, Google Fonts

10. **Colors** (Size: M)
    - Color converter, Gradient generator, Color scheme creator

11. **Network Tools** (Size: M)
    - IP lookup, WHOIS, DNS lookup

12. **AI Meta Tools** (Size: M) - HUGE SEO POTENTIAL (Tools ABOUT AI)
    - ⚠️ Note: Client-side AI execution requires careful cost management
    - Prompt Optimizer (flagship), Token Counter & Cost Calculator (no API cost!), Prompt Template Library (educational, no API cost), Context Window Optimizer, Code Explainer, Code Review Assistant

13. **Other Tools** (Size: Varies)
    - Character count, Unicode lookup, Date/Time calculator, API Tester

#### Approach

- Complete one category at a time
- Monitor analytics after each deployment
- Let data guide prioritization
- Optimize based on traffic and revenue

**Deliverable:** Comprehensive Codemata with 50+ developer tools

---

### Phase 11: Convertly App (Size: L)

**Goal:** Build conversion tools app using learnings from Codemata

#### Tasks

**10.1 Copy & Adapt**

- [ ] Create `apps/convertly/` based on Codemata
- [ ] Change theme to purple
- [ ] Adapt layout components
- [ ] Update branding

**10.2 Initial Converters** (8-10 tools)

- [ ] Length Converter
- [ ] Weight/Mass Converter
- [ ] Volume Converter
- [ ] Temperature Converter
- [ ] Data Size Converter
- [ ] Time Zone Converter
- [ ] Numeral System Converter
- [ ] Area Converter

**10.3 AI Content**

- [ ] Adapt AI system for converter content
- [ ] Generate content for each converter

**10.4 Deploy**

- [ ] Set up Vercel project
- [ ] Deploy to convertly.benmvp.com
- [ ] Add analytics and ads

**Deliverable:** Convertly app launched with core converters

---

### Phase 12: Moni App (Size: XL)

**Goal:** Build financial calculator app

#### Tasks

**11.1 Copy & Adapt**

- [ ] Create `apps/moni/` based on Codemata/Convertly
- [ ] Change theme to green
- [ ] Adapt layout components
- [ ] Update branding

**11.2 Initial Calculators** (5-8 tools)

- [ ] Compound Interest Calculator
- [ ] Savings Goal Calculator
- [ ] Simple Mortgage Calculator
- [ ] Loan Pre-payment Calculator
- [ ] ROI Calculator
- [ ] Retirement Calculator (basic)
- [ ] Tip Calculator
- [ ] Currency Converter

**11.3 AI Content**

- [ ] Adapt AI system for calculator content
- [ ] Generate content for each calculator

**11.4 Deploy**

- [ ] Set up Vercel project
- [ ] Deploy to moni.benmvp.com
- [ ] Add analytics and ads

**Deliverable:** Moni app launched with core calculators

---

### Ongoing: Extract Shared Code (When Needed)

**Goal:** Create shared packages ONLY when duplication becomes painful

#### Decision Point

Extract shared code when:
- Making the same change across multiple apps becomes tedious
- Bug fixes need to be applied in multiple places
- Component behavior diverges unintentionally
- The duplication is actually causing real maintenance pain

#### If/When Extracting:

- [ ] Create `@repo/ui` package with truly shared components
- [ ] Create `@repo/typescript-config` if configs are identical
- [ ] Create `@repo/eslint-config` if configs are identical
- [ ] Set up pnpm workspace (if not already done)
- [ ] Set up Turborepo (if not already done)
- [ ] Migrate apps to use shared packages
- [ ] Test everything still works

**Approach:** Extract incrementally, not all at once. Start with the most painful duplication first.

---

### Milestones Summary

| Phase | Size | Key Deliverable                              | Status      |
| ----- | ---- | -------------------------------------------- | ----------- |
| 1     | S    | Codemata with 1 formatter (deployed)         | ✅ Complete |
| 2     | M    | All 8 formatters                             | ✅ Complete |
| 3     | M    | All 6 minifiers (14 total tools)             | ✅ Complete |
| 4     | M    | AI content + build optimization              | ✅ Complete |
| 5     | M    | Polish and public launch                     | ✅ Complete |
| 6     | S    | SQL Formatter (high-traffic addition)        | ✅ Complete |
| 7     | S    | Analytics and ads (monetization)             | ✅ Complete |
| 8     | L    | Encoders/Decoders (5 tools, 19 total)        | ✅ Complete |
| 9     | L    | Validators/Checkers (8+ tools)               | ⏳ Pending  |
| 10+   | Varies | Remaining Codemata categories (40+ tools)  | ⏳ Pending  |
| 11    | L    | Convertly app launch                         | ⏳ Pending  |
| 12    | XL   | Moni app launch                              | ⏳ Pending  |

**Current Status:** Codemata live with **19 tools** (8 formatters + 6 minifiers + 5 encoders/decoders), analytics, and monetization. Ready to expand based on traffic data.

**Key Strategy:** Continue expanding Codemata with high-traffic tools identified through analytics before building other apps. Extract shared code only when duplication hurts.

---

## Future Enhancements

### Near-Term (Next 3-6 months)

**Analytics & Monetization:**

- Google Analytics 4 integration
- Track tool usage and popular tools
- Google AdSense integration
- Strategic ad placement (below tool, in content)
- Monitor revenue and optimize placement

**SEO Improvements:**

- Blog section with coding tips
- Tool comparison pages
- "How-to" guides for each tool
- Internal linking strategy
- Schema.org structured data

**User Experience:**

- Keyboard shortcuts (Cmd+Enter to format)
- Example code snippets ("Load Example")
- Recent tools history (localStorage)
- Favorite tools bookmarking
- Share formatted code (generate link)

### Mid-Term (6-12 months)

**Codemata Expansion (See TODO.md):**

- **Viewers:** SVG Viewer, Markdown Preview, Diff Tool
- **Validators:** HTML, JSON, XML, CSS, A11Y, SEO checkers
- **Encoders/Decoders:** JWT, Base64, URL, HTML entities
- **Generators:** Hash (MD5, SHA), UUID, QR codes, Meta tags
- **Converters:** XML ↔ JSON, CSV ↔ JSON, YAML ↔ JSON
- **Colors:** Color converter, gradient generator, scheme creator
- **Text Tools:** Case converter, text analyzer, line tools
- **Network Tools:** IP lookup, WHOIS, DNS lookup

**Moni Expansion:**

- All calculators from TODO.md
- Interactive charts and visualizations
- PDF export functionality
- Save calculations (with account)
- Compare scenarios side-by-side

**Convertly Expansion:**

- All converters from TODO.md
- Unit favorites
- Conversion history
- Batch conversions
- API access (premium feature?)

### Long-Term (12+ months)

**Platform Features:**

- User accounts (optional)
- Save favorites and history
- API access for tools
- Browser extension
- Mobile apps (React Native)

**Community Features:**

- User-contributed tools
- Tool ratings and reviews
- Code snippet sharing
- Forum/discussions

**Enterprise Features:**

- Teams/workspaces
- Custom branding
- Private deployment
- SLA guarantees
- Priority support

**AI Enhancements:**

- AI code review
- AI bug detection
- AI code explanation
- AI refactoring suggestions
- Multi-model support (Claude, GPT)

### Continuous Improvements

**Performance:**

- Optimize bundle sizes
- Improve ISR cache strategy
- Add service worker for offline support
- Optimize AI generation (parallel, caching)

**Quality:**

- Expand test coverage
- Add E2E tests with Playwright
- Add visual regression testing
- Automated accessibility testing

**Developer Experience:**

- Storybook for component development
- Better error messages
- Improved debugging tools
- More comprehensive docs

**Security:**

- Rate limiting on API routes
- CAPTCHA for abuse prevention
- Content Security Policy hardening
- Regular dependency updates

---

## Appendix

### Useful Resources

**Documentation:**

- [Next.js Docs](https://nextjs.org/docs)
- [Tailwind CSS](https://tailwindcss.com/docs)
- [Radix UI](https://www.radix-ui.com/primitives)
- [shadcn/ui](https://ui.shadcn.com/)
- [CodeMirror](https://codemirror.net/)
- [Gemini API](https://ai.google.dev/docs)
- [Vercel Docs](https://vercel.com/docs)
- [Turborepo Docs](https://turbo.build/repo/docs)

**Tools:**

- [Biome](https://biomejs.dev/) - Linter and formatter
- [Prettier](https://prettier.io/) - Code formatter
- [Terser](https://terser.org/) - JS minifier
- [Vitest](https://vitest.dev/) - Test framework

### Contact & Repository

- **GitHub:** https://github.com/benmvp/tools-app
- **Issues:** Use GitHub Issues for bugs and features
- **Discussions:** Use GitHub Discussions for questions

---

**End of Specification Document**

_This document is a living specification and will be updated as the project evolves._
