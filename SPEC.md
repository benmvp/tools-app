# Tools App - Project Specification

**Version:** 2.0
**Last Updated:** December 21, 2025
**Status:** Planning Phase

---

## Table of Contents

1. [Project Overview & Goals](#project-overview--goals)
2. [Technical Architecture](#technical-architecture)
3. [Tech Stack](#tech-stack)
4. [Monorepo Structure](#monorepo-structure)
5. [Shared Packages](#shared-packages)
6. [AI Content System](#ai-content-system)
7. [Application Specifications](#application-specifications)
8. [UI/UX Design](#uiux-design)
9. [Development Workflow](#development-workflow)
10. [Testing Strategy](#testing-strategy)
11. [Deployment & Infrastructure](#deployment--infrastructure)
12. [Implementation Plan](#implementation-plan)
13. [Future Enhancements](#future-enhancements)

---

## Project Overview & Goals

### Vision

Tools App is a suite of three web applications providing free, high-quality developer and financial tools. Each app focuses on a specific domain while sharing common infrastructure and design patterns.

### Applications

1. **Codemata** (codemata.benmvp.com) - Developer tools for code transformation

   - Code formatters (8 languages/formats)
   - Code minifiers (6 languages/formats)
   - Future: Viewers, validators, encoders, generators, converters

2. **Moni** (moni.benmvp.com) - Financial calculators and planning tools

   - Savings & investment calculators
   - Debt management tools
   - Retirement planning calculators

3. **Convertly** (convertly.benmvp.com) - Unit conversion tools
   - Measurement converters (length, weight, volume, etc.)
   - Time and timezone conversion
   - Data size and numeral system conversion

### Primary Goals

1. **Utility-First:** Provide accurate, fast, and reliable tools that solve real problems
2. **Traffic & Engagement:** Build popular tools that attract consistent users
3. **Learning & Portfolio:** Showcase modern development practices and architecture
4. **Monetization:** Generate revenue through Google Ads (future phase)

### Success Metrics

- User engagement and repeat visits
- Tool accuracy and performance
- SEO rankings for tool-related keywords
- Ad revenue (future)

### Motivation

The project aims to create best-in-class online tools by combining:

- **Modern Tech:** Latest frameworks and libraries for optimal performance
- **AI-Enhanced Content:** High-quality, SEO-optimized educational content generated by AI
- **Developer-First:** Built by a developer, for developers (and anyone needing tools)
- **Scalable Architecture:** Monorepo structure allowing rapid addition of new tools

---

## Technical Architecture

### Architecture Overview

The project uses a **monorepo** structure with three independent Next.js applications sharing common packages. This architecture provides:

- **Code Reuse:** Shared UI components, configurations, and utilities
- **Consistency:** Unified development patterns across all apps
- **Flexibility:** Each app can be deployed and scaled independently
- **Maintainability:** Centralized tooling and dependency management

### Key Architectural Decisions

#### 1. Server-Side Transformations

All code transformations happen server-side via Next.js Server Actions:

- **Security:** No arbitrary code execution in browser
- **Bundle Size:** No heavy transformation libraries sent to client
- **Consistency:** Same transformation logic for all users
- **Simplicity:** Single source of truth for transformation logic

#### 2. AI Content Generation

Content is generated at build time and cached:

- **Build Time:** Gemini API generates all content during build
- **ISR:** 24-hour revalidation keeps content fresh without manual deploys
- **Fallback:** Cached content used if API fails during revalidation
- **Manual Regeneration:** `pnpm regenerate-ai` script for on-demand updates

#### 3. Static Routing with Dynamic Content

- **Static Routes:** All tool pages are pre-rendered at build time
- **Dynamic Content:** AI-generated content via ISR
- **SEO Optimized:** Fully crawlable, fast initial load

#### 4. Theme-Agnostic Shared Components

- Shared UI components accept theme configuration
- Each app defines its own color scheme
- Consistent layout and behavior across apps
- Easy branding customization per app

---

## Tech Stack

### Core Technologies

| Category            | Technology | Version | Purpose                    |
| ------------------- | ---------- | ------- | -------------------------- |
| **Runtime**         | Node.js    | Latest  | Server-side execution      |
| **Package Manager** | pnpm       | Latest  | Workspace management       |
| **Framework**       | Next.js    | Latest  | Full-stack React framework |
| **Language**        | TypeScript | Latest  | Type-safe development      |
| **Monorepo**        | Turborepo  | Latest  | Build orchestration        |

### Frontend Stack

| Category          | Technology      | Purpose                         |
| ----------------- | --------------- | ------------------------------- |
| **UI Components** | Radix UI        | Accessible primitives           |
| **UI Library**    | shadcn/ui       | Pre-built components            |
| **Styling**       | Tailwind CSS    | Utility-first styling           |
| **Code Editor**   | CodeMirror 6    | Syntax-highlighted input/output |
| **Icons**         | Lucide React    | Icon system                     |
| **Forms**         | React Hook Form | Form management                 |

### Backend & AI

| Category            | Technology              | Purpose             |
| ------------------- | ----------------------- | ------------------- |
| **AI Model**        | Gemini 2.0 Flash        | Content generation  |
| **Validation**      | Zod                     | Schema validation   |
| **Code Formatting** | Prettier, Biome         | Code transformation |
| **Minification**    | Terser, clean-css, etc. | Code minification   |

### Development Tools

| Category          | Technology | Purpose           |
| ----------------- | ---------- | ----------------- |
| **Linting**       | Biome      | Code linting      |
| **Type Checking** | TypeScript | Static analysis   |
| **Testing**       | Vitest     | Unit testing      |
| **Git Hooks**     | (Optional) | Pre-commit checks |

### Deployment

| Category      | Technology                | Purpose              |
| ------------- | ------------------------- | -------------------- |
| **Platform**  | Vercel                    | Hosting & deployment |
| **Domains**   | Custom domains            | Brand identity       |
| **Analytics** | Google Analytics (future) | User tracking        |
| **Ads**       | Google Ads (future)       | Monetization         |

---

## Monorepo Structure

### Directory Layout

```
tools-app/
├── apps/
│   ├── codemata/                 # Developer tools app
│   │   ├── app/                  # Next.js app directory
│   │   │   ├── layout.tsx        # Root layout
│   │   │   ├── page.tsx          # Home page
│   │   │   ├── formatters/       # Formatter tools
│   │   │   │   ├── info.ts       # Tool metadata
│   │   │   │   ├── formatters.ts # Tool configurations
│   │   │   │   ├── actions.ts    # Server actions
│   │   │   │   ├── ai.ts         # AI content generation
│   │   │   │   └── [slug]/       # Dynamic tool pages
│   │   │   │       └── page.tsx
│   │   │   └── minifiers/        # Minifier tools
│   │   │       └── ...           # Same structure
│   │   ├── components/           # App-specific components
│   │   ├── lib/                  # Utility functions
│   │   ├── public/               # Static assets
│   │   ├── styles/               # Global styles
│   │   ├── types.ts              # Shared types
│   │   ├── theme.ts              # App theme config
│   │   ├── next.config.mjs       # Next.js config
│   │   ├── tailwind.config.ts    # Tailwind config
│   │   ├── tsconfig.json         # TypeScript config
│   │   └── package.json          # Dependencies
│   │
│   ├── moni/                     # Financial tools app
│   │   └── ...                   # Similar structure
│   │
│   └── convertly/                # Conversion tools app
│       └── ...                   # Similar structure
│
├── packages/
│   ├── ui/                       # Shared UI components
│   │   ├── src/
│   │   │   ├── components/       # React components
│   │   │   │   ├── layout/       # Header, Footer, RootLayout
│   │   │   │   ├── transformer/  # Tool transformer UI
│   │   │   │   ├── content/      # Content sections
│   │   │   │   └── ui/           # shadcn/ui components
│   │   │   ├── lib/              # Utilities
│   │   │   ├── hooks/            # Custom hooks
│   │   │   └── types/            # Shared types
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   ├── typescript-config/        # Shared TS configs
│   │   ├── base.json
│   │   ├── nextjs.json
│   │   └── package.json
│   │
│   └── eslint-config/            # Shared ESLint configs
│       ├── base.js
│       ├── next.js
│       └── package.json
│
├── scripts/
│   └── regenerate-ai.js          # Manual AI content regeneration
│
├── .gitignore
├── pnpm-workspace.yaml           # pnpm workspace config
├── turbo.json                    # Turborepo config
├── package.json                  # Root package.json
├── README.md
├── TODO.md                       # Future features
└── SPEC.md                       # This document
```

### Workspace Configuration

**pnpm-workspace.yaml:**

```yaml
packages:
  - 'apps/*'
  - 'packages/*'
```

**Root package.json scripts:**

```json
{
  "scripts": {
    "dev": "turbo dev",
    "build": "turbo build",
    "start": "turbo start",
    "lint": "turbo lint",
    "type-check": "turbo type-check",
    "test": "turbo test",
    "format": "biome format --write .",
    "regenerate-ai": "node scripts/regenerate-ai.js"
  }
}
```

### Port Assignments

- **Codemata:** 3001 (dev), Production via Vercel
- **Moni:** 3002 (dev), Production via Vercel
- **Convertly:** 3003 (dev), Production via Vercel

---

## Shared Packages

### @repo/ui

The shared UI package provides theme-agnostic components used across all apps.

#### Components

**Layout Components:**

- `BaseRootLayout` - Root layout with theme provider, fonts, metadata
- `Header` - Top navigation with logo, menu, search, theme toggle
- `Footer` - Footer with links to benmvp.com, copyright, legal

**Tool Components:**

- `Transformer` - Dual CodeMirror editor with configuration and actions
- `ContentSection` - Collapsible section with heading and markdown content
- `ContentSections` - Wrapper for multiple content sections

**UI Primitives (shadcn/ui):**

- Button, Card, Dialog, Dropdown Menu
- Accordion, Tabs, Toast
- Form components

#### Theme System

Components accept theme configuration via context:

```typescript
interface AppTheme {
  colors: {
    primary: string      // Tailwind color class (e.g., 'blue')
    secondary: string
    accent: string
  }
  brand: {
    name: string
    logo: React.ReactNode
    url: string
  }
}

// Each app provides its theme
const codeMataTheme: AppTheme = { ... }
const moniTheme: AppTheme = { ... }
const convertlyTheme: AppTheme = { ... }
```

#### Package Structure

```
packages/ui/
├── src/
│   ├── components/
│   │   ├── layout/
│   │   │   ├── header.tsx
│   │   │   ├── footer.tsx
│   │   │   └── base-root-layout.tsx
│   │   ├── transformer/
│   │   │   ├── transformer.tsx
│   │   │   ├── code-editor.tsx
│   │   │   └── config-panel.tsx
│   │   ├── content/
│   │   │   ├── content-section.tsx
│   │   │   └── content-sections.tsx
│   │   └── ui/              # shadcn/ui components
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       └── ...
│   ├── lib/
│   │   └── utils.ts
│   ├── hooks/
│   │   └── use-theme.ts
│   └── types/
│       └── index.ts
├── package.json
└── tsconfig.json
```

### @repo/typescript-config

Shared TypeScript configurations:

- **base.json** - Base config with strict settings
- **nextjs.json** - Extends base, adds Next.js specific options

### @repo/eslint-config

Shared ESLint configurations:

- **base.js** - Base rules for all projects
- **next.js** - Next.js specific rules
- **react.js** - React specific rules

---

## AI Content System

### Overview

The AI Content System uses Google Gemini to generate high-quality, SEO-optimized educational content for each tool. Content is generated at build time and cached using Next.js ISR (Incremental Static Regeneration).

### Content Generation Flow

```
Build Time:
1. Next.js builds static pages
2. For each tool page, call AI content generation
3. Gemini API returns structured content (Zod validated)
4. Convert to TypeScript objects
5. Render page with AI content
6. Deploy to Vercel

Runtime (ISR):
1. User requests page (after 24 hours)
2. Return cached version immediately
3. Background: Trigger revalidation
4. Call Gemini API for fresh content
5. Update cache with new content
6. If API fails: Keep existing cached content

Manual Regeneration:
1. Run `pnpm regenerate-ai` script
2. Trigger on-demand revalidation for all pages
3. Fresh content generated for selected tools
```

### Gemini API Configuration

**Model:** `gemini-2.0-flash` (or latest available)

**API Integration:**

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai'

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!)
const model = genAI.getGenerativeModel({
  model: 'gemini-2.0-flash',
  generationConfig: {
    responseMimeType: 'application/json',
    responseSchema: toolContentSchema, // Zod to JSON Schema
  },
})
```

**Environment Variables:**

- `GOOGLE_API_KEY` - Google AI API key (required)

### Content Schema

All AI-generated content follows a strict Zod schema:

```typescript
import { z } from 'zod'

const contentSectionSchema = z.object({
  heading: z.string().describe('Section heading'),
  content: z.string().describe('Markdown formatted content'),
})

const toolContentSchema = z.object({
  intro: z.string().describe('Introductory paragraph (1-2 sentences)'),

  seo: z.object({
    title: z.string().describe('Page title (50-60 chars)'),
    description: z.string().describe('Meta description (150-160 chars)'),
    keywords: z.string().describe('Comma-separated keywords'),
  }),

  howToUse: contentSectionSchema
    .optional()
    .describe('Step-by-step instructions (optional, users usually understand)'),

  features: contentSectionSchema.describe('Features and benefits of the tool'),

  rationale: contentSectionSchema.describe(
    'Why use this tool / online formatter',
  ),

  purpose: contentSectionSchema.describe(
    'What is the language/format this tool works with',
  ),

  integrate: contentSectionSchema.describe(
    'How to integrate formatting into workflow',
  ),

  faq: contentSectionSchema.describe('Frequently asked questions and answers'),

  recommendations: contentSectionSchema.describe(
    'Links to other related tools on the site',
  ),

  resources: contentSectionSchema.describe(
    'External resources and documentation links',
  ),
})

export type ToolContent = z.infer<typeof toolContentSchema>
```

**Validation Flow:**

1. Gemini returns JSON matching schema
2. Zod validates structure and types
3. Convert to TypeScript object (fully typed)
4. Use throughout app with type safety

### AI Prompts

The AI prompt system consists of a system message (context) and user message (specific request).

#### System Message Template

```markdown
You are a copywriter and SEO expert for an application called **{APP_NAME}** that provides developer tools.

Your task is to generate content for various online {TOOL_TYPE} tools that {APP_NAME} offers. The content will be used to create web pages for each tool, providing information on how to use the tool, its features, benefits, and integration options.

## Tone and Style

- Friendly and approachable
- Educational and helpful
- Use clear and concise language
- Use bullet points and numbered lists for easy readability
- Write in a way that is easy to understand for both novice and experienced developers

## Content Sections

### Introductory Paragraph (intro)

- A single paragraph (1-2 sentences) explaining the purpose of the tool
- Highlight the benefits: cleaning messy code, improving readability, consistency
- Mention configuration options (e.g., indentation)
- Target audience: developers
- Adapt to be specific to the language being formatted
- Output: Plain text (no markdown)
- Example: "Tired of messy HTML code? Our free online HTML formatter instantly cleans up your code, making it easier to understand and maintain. Choose from various indentation options to match your coding style."

### SEO Metadata (seo)

- **title**: Page title optimized for search (50-60 characters)
  - Format: "{Language/Format} {Tool Type} | {App Name}"
  - Example: "JavaScript & TypeScript Formatter | Codemata Developer Tools"
- **description**: Meta description for search results (150-160 characters)
  - Include tool name, key benefit, and call-to-action
  - Example: "Format and beautify JavaScript & TypeScript code instantly. Free online formatter with customizable indentation. Clean, readable code in seconds."
- **keywords**: Comma-separated keywords for SEO
  - Include: tool type, language, variations, use cases
  - Example: "javascript formatter, typescript formatter, js beautifier, code formatter, prettier online"

### How to Use (howToUse) - Optional

- **heading**: Suggest a relevant heading (e.g., "How to use the HTML Formatter")
- **content**: Numbered list (3-5 steps) with clear instructions
  - Paste code → Select options → View result → Copy output
  - Keep it simple, users generally understand how tools work
- Output: Markdown format

### Features and Benefits (features)

- **heading**: Suggest relevant heading (e.g., "Features and benefits")
- **content**: Bulleted list highlighting tool features
  - Focus on user value and benefits
  - Include: automatic formatting, customizable options, fast performance
  - Add language-specific features where relevant
- Output: Markdown format

### Rationale (rationale)

- **heading**: Suggest heading (e.g., "Why use an online HTML Formatter?")
- **content**: Bulleted list explaining benefits
  - Address developer pain points
  - Benefits: readability, debugging, consistency, collaboration, time savings
  - Tailor to specific language while keeping general benefits
- Output: Markdown format

### Purpose (purpose)

- **heading**: Language explanation (e.g., "What is GraphQL?", "What is XML?")
- **content**: Brief paragraph explaining the language/format
  - What it is and its role
  - Common use cases
  - Why formatting matters for this language
- Output: Markdown format

### Integration (integrate)

- **heading**: Workflow integration (e.g., "Integrating formatting into your workflow")
- **content**: Tips for using the tool in development workflow
  - Editor plugins and extensions
  - CI/CD integration
  - Git hooks
  - Team standards
- Output: Markdown format

### FAQ (faq)

- **heading**: "Frequently Asked Questions"
- **content**: 3-5 common questions and concise answers
  - Format as markdown with **Q:** and **A:**
  - Address: tool usage, options, privacy, cost, language support
- Output: Markdown format

### Recommendations (recommendations)

- **heading**: "Related Tools"
- **content**: Links to other tools on the site
  - Reference the available tools list provided
  - Suggest 3-5 relevant tools
  - Format as markdown links: `- [Tool Name](url) - Brief description`
- Output: Markdown format

### Resources (resources)

- **heading**: "External Resources"
- **content**: Links to official documentation and learning resources
  - Official language/format documentation
  - Style guides and best practices
  - Popular formatters and tools
  - Format as markdown links with descriptions
- Output: Markdown format

## Important Guidelines

- Be specific to the language/format being discussed
- Use concrete examples where helpful
- Keep content scannable with headings and lists
- Maintain consistent, friendly tone throughout
- Optimize for SEO without keyword stuffing
- Ensure all content is accurate and up-to-date
```

#### User Message Template

```markdown
Generate the content for the following {TOOL_TYPE} tool: {TOOL_NAME}

All available tools on the site:
{AVAILABLE_TOOLS_LIST}

Remember to:

- Make content specific to {LANGUAGE/FORMAT}
- Include relevant keywords naturally
- Link to related tools from the available tools list
- Keep tone friendly and educational
```

#### Example: CSS Formatter

**System Message:** (As above, with APP_NAME=Codemata, TOOL_TYPE=formatter)

**User Message:**

```
Generate the content for the following formatter tool: CSS/SCSS Formatter

All available tools:
- CSS/SCSS Formatter - /css-formatter
- GraphQL Formatter - /graphql-formatter
- HTML Formatter - /html-formatter
- JSON Formatter - /json-formatter
- JavaScript & TypeScript Formatter - /typescript-formatter
- Markdown/MDX Formatter - /markdown-formatter
- XML Formatter - /xml-formatter
- YAML Formatter - /yaml-formatter
- CSS Minifier - /css-minifier
- HTML Minifier - /html-minifier
- JSON Minifier - /json-minifier
- JavaScript & TypeScript Minifier - /typescript-minifier
- SVG Minifier - /svg-minifier
- XML Minifier - /xml-minifier
```

### Caching Strategy

**Production Cache:**

```typescript
// In-memory cache for API requests during build
const REQUEST_CACHE = new Map<string, ToolContent>()

async function getCachedToolContent(
  cacheKey: string,
  systemMessage: string,
  userMessage: string,
): Promise<ToolContent | undefined> {
  // Check in-memory cache first
  if (REQUEST_CACHE.has(cacheKey)) {
    return REQUEST_CACHE.get(cacheKey)
  }

  // Generate new content
  const content = await generateToolContent(systemMessage, userMessage)

  // Cache the result
  REQUEST_CACHE.set(cacheKey, content)

  return content
}
```

**ISR Configuration:**

```typescript
// In page.tsx
export const revalidate = 86400 // 24 hours

export async function generateMetadata({ params }) {
  const toolContent = await getToolContent(params.slug)
  // ... return metadata
}
```

**Error Handling:**

```typescript
async function getToolContent(slug: string): Promise<ToolContent | undefined> {
  try {
    const content = await getCachedToolContent(...)
    return content
  } catch (error) {
    console.error('AI generation failed:', error)

    // During build: fail fast
    if (process.env.NODE_ENV === 'production' && !isRevalidation()) {
      throw error
    }

    // During ISR revalidation: use cached version
    return getCachedVersion(slug) // Return existing cached page
  }
}
```

### Manual Regeneration Script

**scripts/regenerate-ai.js:**

```javascript
#!/usr/bin/env node

/**
 * Manually trigger revalidation for tool pages
 * Usage: node scripts/regenerate-ai.js [app] [slug]
 * Example: node scripts/regenerate-ai.js codemata typescript-formatter
 */

const apps = ['codemata', 'moni', 'convertly']
const targetApp = process.argv[2]
const targetSlug = process.argv[3]

if (targetApp && !apps.includes(targetApp)) {
  console.error(`Invalid app: ${targetApp}`)
  process.exit(1)
}

// Trigger on-demand revalidation via Vercel API
// or use fetch to hit revalidate endpoint
async function revalidate(app, slug) {
  const url = `https://${app}.benmvp.com/${slug}`
  const revalidateUrl = `https://${app}.benmvp.com/api/revalidate?path=/${slug}&secret=${process.env.REVALIDATE_SECRET}`

  await fetch(revalidateUrl)
  console.log(`Revalidated: ${url}`)
}

// Main execution
// ... implementation
```

---

## Application Specifications

### Codemata (Developer Tools)

**Domain:** codemata.benmvp.com
**Purpose:** Code transformation tools for developers

#### Tool Categories

**1. Formatters** - Beautify and format code with consistent styling

| Tool ID   | Display Name | Languages                        | Library                         | Config      |
| --------- | ------------ | -------------------------------- | ------------------------------- | ----------- |
| `css`     | CSS/SCSS     | CSS, SCSS                        | Prettier                        | Indentation |
| `graphql` | GraphQL      | GraphQL                          | Prettier                        | Indentation |
| `html`    | HTML         | HTML                             | Prettier                        | Indentation |
| `json`    | JSON         | JSON                             | Prettier                        | Indentation |
| `md`      | Markdown/MDX | Markdown, MDX                    | Prettier                        | Indentation |
| `ts`      | JS/TS        | JavaScript, TypeScript, JSX, TSX | Biome/Prettier                  | Indentation |
| `xml`     | XML          | XML                              | Prettier + @prettier/plugin-xml | Indentation |
| `yaml`    | YAML         | YAML                             | Prettier                        | Indentation |

**2. Minifiers** - Compress code by removing whitespace and optimizing

| Tool ID | Display Name | Languages              | Library              | Config |
| ------- | ------------ | ---------------------- | -------------------- | ------ |
| `css`   | CSS          | CSS                    | clean-css            | None   |
| `html`  | HTML         | HTML                   | html-minifier-terser | None   |
| `json`  | JSON         | JSON                   | JSON.stringify       | None   |
| `svg`   | SVG          | SVG                    | svgo                 | None   |
| `ts`    | JS/TS        | JavaScript, TypeScript | Terser               | None   |
| `xml`   | XML          | XML                    | minify-xml           | None   |

#### Route Structure

```
/                           - Home page (hero + categories + tool grid)
/typescript-formatter       - JS/TS formatter tool page
/json-formatter            - JSON formatter tool page
/css-formatter             - CSS formatter tool page
... (all formatters)
/typescript-minifier       - JS/TS minifier tool page
/json-minifier             - JSON minifier tool page
... (all minifiers)
```

#### Tool Configuration

**Formatter Configuration Example:**

```typescript
// apps/codemata/app/formatters/formatters.ts

import type { TransformerConfig } from '../../types'

export type Indentation = 'two-spaces' | 'four-spaces' | 'tabs'

export const indentationConfig: TransformerConfig<Indentation> = {
  id: 'indentation',
  label: 'Indentation',
  options: [
    { label: 'Two Spaces', value: 'two-spaces' },
    { label: 'Four Spaces', value: 'four-spaces' },
    { label: 'Tabs', value: 'tabs' },
  ],
}

export interface Formatter {
  action: (input: string, config: FormatterConfig) => Promise<string>
  configs: TransformerConfig[]
}

const typescriptFormatter: Formatter = {
  action: formatTypescriptAction,
  configs: [indentationConfig],
}

export const FORMATTERS: Record<FormatterId, Formatter> = {
  ts: typescriptFormatter,
  json: jsonFormatter,
  // ... rest
}
```

**Tool Metadata Example:**

```typescript
// apps/codemata/app/formatters/info.ts

import type { TransformerInfo } from '../../types'
import CodeIcon from '@mui/icons-material/Code'

type FormatterInfo = TransformerInfo<FormatterId>

const TS: FormatterInfo = {
  id: 'ts',
  slug: 'typescript',
  displayName: 'JS/TS',
  pageTitle: 'JavaScript & TypeScript Formatter',
  Icon: CodeIcon,
  url: '/typescript-formatter',
}

export const FORMATTERS_INFO: Record<FormatterId, FormatterInfo> = {
  ts: TS,
  json: JSON,
  // ... rest
}
```

#### Server Actions

**Formatter Action Example:**

```typescript
// apps/codemata/app/formatters/actions.ts

'use server'

import { format } from 'prettier'
import type { Indentation } from './types'

export async function formatTypescriptAction(
  input: string,
  config: { indentation: Indentation },
): Promise<string> {
  const indent = getIndentSize(config.indentation)

  try {
    const formatted = await format(input, {
      parser: 'typescript',
      tabWidth: indent.size,
      useTabs: indent.useTabs,
      semi: true,
      singleQuote: true,
      trailingComma: 'es5',
    })

    return formatted
  } catch (error) {
    throw new Error(`Formatting failed: ${error.message}`)
  }
}

function getIndentSize(indentation: Indentation) {
  switch (indentation) {
    case 'two-spaces':
      return { size: 2, useTabs: false }
    case 'four-spaces':
      return { size: 4, useTabs: false }
    case 'tabs':
      return { size: 2, useTabs: true }
  }
}
```

#### Page Implementation

```typescript
// apps/codemata/app/formatters/[slug]/page.tsx

import { notFound } from 'next/navigation'
import { TransformerUi } from '@repo/ui/components/transformer'
import { ContentSectionsUi } from '@repo/ui/components/content'
import { getFormatterContent } from '../ai'
import { FORMATTERS, FORMATTERS_INFO } from '../formatters'

// ISR configuration
export const revalidate = 86400 // 24 hours

// Static params for build
export function generateStaticParams() {
  return Object.values(FORMATTERS_INFO).map(({ slug }) => ({
    slug
  }))
}

// Metadata generation
export async function generateMetadata({ params }) {
  const formatter = getFormatterBySlug(params.slug)
  if (!formatter) return notFound()

  const content = await getFormatterContent(formatter.id)

  return {
    title: content?.seo.title || formatter.pageTitle,
    description: content?.seo.description,
    keywords: content?.seo.keywords
  }
}

// Page component
export default async function FormatterPage({ params }) {
  const formatter = getFormatterBySlug(params.slug)
  if (!formatter) return notFound()

  const content = await getFormatterContent(formatter.id)
  const tool = FORMATTERS[formatter.id]

  return (
    <>
      <h1>{formatter.pageTitle}</h1>

      {content?.intro && <p>{content.intro}</p>}

      <TransformerUi
        action={tool.action}
        configs={tool.configs}
        actionLabel="Format"
        stateLabel="Formatted"
        displayName={formatter.displayName}
      />

      <ContentSectionsUi
        sections={[
          content?.features,
          content?.rationale,
          content?.purpose,
          content?.integrate,
          content?.faq,
          content?.recommendations,
          content?.resources
        ].filter(Boolean)}
      />
    </>
  )
}
```

#### Theme Configuration

```typescript
// apps/codemata/theme.ts

export const codeMataTheme = {
  colors: {
    primary: 'blue', // Tailwind color
    secondary: 'slate',
    accent: 'cyan',
  },
  brand: {
    name: 'Codemata',
    url: 'https://codemata.benmvp.com',
    tagline: 'Developer Tools',
  },
}
```

### Moni (Financial Tools)

**Domain:** moni.benmvp.com
**Purpose:** Financial calculators and planning tools

#### Tool Categories

See TODO.md for complete list. Key categories:

- **Savings & Investment:** Compound interest, savings goals, retirement planning
- **Debt Management:** Loan calculators, debt payoff strategies
- **Utilities:** Currency converter, tip calculator, net worth calculator

#### Route Structure

```
/                              - Home page
/compound-interest-calculator  - Calculator page
/savings-goal-calculator       - Calculator page
... (all calculators)
```

#### Calculator Pattern

Similar structure to Codemata but with calculator-specific components:

```typescript
// Calculator configuration
interface Calculator {
  action: (inputs: CalculatorInputs) => Promise<CalculatorResults>
  inputs: InputField[]
  resultFormat: ResultDisplay
}

// Calculator page renders:
// 1. Calculator form (inputs)
// 2. Results display (charts + breakdown)
// 3. AI-generated educational content
```

#### Theme Configuration

```typescript
// apps/moni/theme.ts

export const moniTheme = {
  colors: {
    primary: 'green', // Financial/money color
    secondary: 'slate',
    accent: 'emerald',
  },
  brand: {
    name: 'Moni',
    url: 'https://moni.benmvp.com',
    tagline: 'Financial Tools',
  },
}
```

### Convertly (Conversion Tools)

**Domain:** convertly.benmvp.com
**Purpose:** Unit and format conversion tools

#### Tool Categories

See TODO.md for complete list. Key categories:

- **Measurement:** Length, weight, volume, temperature, area
- **Time:** Time zones, time units
- **Data:** Data sizes, numeral systems
- **Text:** Morse code, Roman numerals

#### Route Structure

```
/                        - Home page
/length-converter        - Converter page
/temperature-converter   - Converter page
... (all converters)
```

#### Theme Configuration

```typescript
// apps/convertly/theme.ts

export const convertlyTheme = {
  colors: {
    primary: 'purple', // Conversion/transformation color
    secondary: 'slate',
    accent: 'violet',
  },
  brand: {
    name: 'Convertly',
    url: 'https://convertly.benmvp.com',
    tagline: 'Conversion Tools',
  },
}
```

---

## UI/UX Design

### Design System

#### Color System

Each app uses a primary color with Tailwind CSS:

**Codemata:** Blue theme

- Primary: `blue-600` (#2563eb)
- Hover: `blue-700` (#1d4ed8)
- Light: `blue-50` (#eff6ff)

**Moni:** Green theme

- Primary: `green-600` (#16a34a)
- Hover: `green-700` (#15803d)
- Light: `green-50` (#f0fdf4)

**Convertly:** Purple theme

- Primary: `purple-600` (#9333ea)
- Hover: `purple-700` (#7e22ce)
- Light: `purple-50` (#faf5ff)

**Neutral Colors:** All apps share neutral colors

- Gray: `slate-*` scale
- Text: `slate-900` (dark), `slate-50` (light)
- Border: `slate-200` (light), `slate-700` (dark)

#### Typography

**Font System:**

```typescript
// Next.js font configuration
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
})

// Tailwind typography scale
const typography = {
  h1: 'text-4xl font-bold', // Page titles
  h2: 'text-3xl font-bold', // Section headings
  h3: 'text-2xl font-semibold', // Subsection headings
  body: 'text-base', // Body text
  small: 'text-sm', // Secondary text
  code: 'font-mono text-sm', // Code/technical text
}
```

#### Spacing & Layout

**Container:**

- Max width: `1280px` (container)
- Padding: `px-4` mobile, `px-6` tablet, `px-8` desktop
- Gap: `space-y-8` for vertical sections

**Grid System:**

```typescript
// Tool grid (home page)
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
  {tools.map(tool => <ToolCard key={tool.id} {...tool} />)}
</div>

// Transformer layout
<div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
  <CodeEditor label="Input" />
  <CodeEditor label="Output" />
</div>
```

#### Responsive Breakpoints

```typescript
// Tailwind breakpoints
{
  sm: '640px',   // Mobile landscape
  md: '768px',   // Tablet
  lg: '1024px',  // Desktop
  xl: '1280px',  // Large desktop
  '2xl': '1536px' // Extra large
}
```

**Responsive Patterns:**

- Mobile: Single column, stacked editors
- Tablet: Two columns for editors, grid layouts
- Desktop: Full grid layouts, side-by-side editors

#### Dark Mode

**Implementation:** Tailwind CSS dark mode with class strategy

```typescript
// tailwind.config.ts
export default {
  darkMode: 'class',
  // ...
}

// Theme toggle stores preference in localStorage
// Root layout applies 'dark' class to <html>
```

**Color Adjustments:**

```css
/* Light mode */
.bg-background {
  @apply bg-white;
}
.text-foreground {
  @apply text-slate-900;
}

/* Dark mode */
.dark .bg-background {
  @apply bg-slate-950;
}
.dark .text-foreground {
  @apply text-slate-50;
}
```

### Component Library (shadcn/ui)

**Core Components to Install:**

```bash
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
npx shadcn-ui@latest add accordion
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add dropdown-menu
npx shadcn-ui@latest add form
npx shadcn-ui@latest add input
npx shadcn-ui@latest add label
npx shadcn-ui@latest add select
npx shadcn-ui@latest add toast
npx shadcn-ui@latest add tooltip
```

**Customization:**
All components customized with theme colors via CSS variables:

```css
@layer base {
  :root {
    --primary: 217 91% 60%; /* blue-600 */
    --primary-foreground: 0 0% 100%;
    /* ... other colors */
  }

  .dark {
    --primary: 217 91% 60%;
    --primary-foreground: 0 0% 100%;
    /* ... dark mode colors */
  }
}
```

### Layout Components

#### Header

**Structure:**

```
┌─────────────────────────────────────────────┐
│ [Logo] Codemata          [Search] [Theme]   │
│        ▾ Formatters ▾ Minifiers             │
└─────────────────────────────────────────────┘
```

**Features:**

- Logo with app name
- Dropdown navigation for tool categories
- Search icon (opens search modal)
- Theme toggle (sun/moon icon)
- Responsive: Hamburger menu on mobile

**Implementation:**

```tsx
// @repo/ui/components/layout/header.tsx
export function Header({ theme, categories }: HeaderProps) {
  return (
    <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur">
      <div className="container flex h-16 items-center justify-between">
        <div className="flex items-center gap-6">
          <Link href="/" className="flex items-center gap-2">
            {theme.brand.logo}
            <span className="font-bold">{theme.brand.name}</span>
          </Link>

          <nav className="hidden md:flex gap-4">
            {categories.map((category) => (
              <DropdownMenu key={category.id}>
                <DropdownMenuTrigger>{category.name}</DropdownMenuTrigger>
                <DropdownMenuContent>
                  {category.tools.map((tool) => (
                    <DropdownMenuItem key={tool.id} asChild>
                      <Link href={tool.url}>{tool.displayName}</Link>
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            ))}
          </nav>
        </div>

        <div className="flex items-center gap-2">
          <Button variant="ghost" size="icon" onClick={openSearch}>
            <SearchIcon />
          </Button>
          <ThemeToggle />
        </div>
      </div>
    </header>
  )
}
```

#### Footer

**Structure:**

```
┌─────────────────────────────────────────────┐
│ © 2025 BenMVP                               │
│ [Link to benmvp.com]                        │
└─────────────────────────────────────────────┘
```

**Features:**

- Copyright notice
- Link to benmvp.com
- Simple, minimal design

#### Home Page

**Layout:**

1. **Hero Section** - Value proposition and search
2. **Category Cards** - Visual grid of tool categories
3. **Tool Grid** - All tools organized by category

**Hero Example:**

```tsx
<section className="py-20 text-center">
  <h1 className="text-5xl font-bold mb-4">
    Developer Tools for the Modern Web
  </h1>
  <p className="text-xl text-muted-foreground mb-8">
    Format, minify, and transform code instantly
  </p>
  <div className="max-w-md mx-auto">
    <SearchInput placeholder="Search tools..." />
  </div>
</section>
```

**Category Card:**

```tsx
<Card className="hover:shadow-lg transition-shadow">
  <CardHeader>
    <div className="w-12 h-12 rounded-lg bg-primary/10 flex items-center justify-center mb-4">
      <CategoryIcon className="w-6 h-6 text-primary" />
    </div>
    <CardTitle>Formatters</CardTitle>
    <CardDescription>
      Beautify and format code with consistent styling
    </CardDescription>
  </CardHeader>
  <CardContent>
    <div className="flex flex-wrap gap-2">
      {tools.map((tool) => (
        <Link key={tool.id} href={tool.url}>
          <Badge variant="secondary">{tool.displayName}</Badge>
        </Link>
      ))}
    </div>
  </CardContent>
</Card>
```

### Tool Page Layout

**Structure:**

```
┌────────────────────────────────────┐
│ JavaScript & TypeScript Formatter  │ ← Page title
│                                    │
│ Intro paragraph from AI...         │ ← AI content
│                                    │
│ ┌──────────────┬──────────────┐   │
│ │ Input        │ Output       │   │ ← Transformer
│ │ [CodeEditor] │ [CodeEditor] │   │
│ │              │              │   │
│ └──────────────┴──────────────┘   │
│ [ Indentation: ▾ ] [Format] ✓     │ ← Config + Action
│                                    │
│ ▼ Features and Benefits            │ ← AI content (expanded)
│   - Automatic indentation...       │
│                                    │
│ ▶ Why use this tool?               │ ← AI content (collapsed)
│ ▶ What is TypeScript?              │
│ ▶ Integration tips                 │
│ ▶ FAQ                              │
│ ▶ Related Tools                    │
│ ▶ Resources                        │
└────────────────────────────────────┘
```

### Transformer Component

**Core component for all code transformation tools:**

```tsx
// @repo/ui/components/transformer/transformer.tsx

interface TransformerProps {
  action: (input: string, config: any) => Promise<string>
  configs?: TransformerConfig[]
  actionLabel: string // "Format", "Minify", etc.
  stateLabel: string // "Formatted", "Minified", etc.
  displayName: string
}

export function TransformerUi({
  action,
  configs,
  actionLabel,
  stateLabel,
  displayName,
}: TransformerProps) {
  const [input, setInput] = useState('')
  const [output, setOutput] = useState('')
  const [config, setConfig] = useState(getDefaultConfig(configs))
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string>()

  const handleTransform = async () => {
    setLoading(true)
    setError(undefined)

    try {
      const result = await action(input, config)
      setOutput(result)
      toast.success(`${stateLabel} successfully!`)
    } catch (err) {
      setError(err.message)
      toast.error(`Failed to ${actionLabel.toLowerCase()}`)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-4">
      {/* Editors */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <CodeEditor
          label="Input"
          value={input}
          onChange={setInput}
          language={getLanguage(displayName)}
        />
        <CodeEditor
          label="Output"
          value={output}
          readOnly
          language={getLanguage(displayName)}
          error={error}
        />
      </div>

      {/* Configuration + Actions */}
      <div className="flex items-center gap-4 flex-wrap">
        {configs?.map((config) => (
          <ConfigControl
            key={config.id}
            config={config}
            value={config[config.id]}
            onChange={(v) => setConfig({ ...config, [config.id]: v })}
          />
        ))}

        <div className="ml-auto flex gap-2">
          <Button
            onClick={handleTransform}
            disabled={!input || loading}
            className="min-w-32"
          >
            {loading ? <Spinner /> : actionLabel}
          </Button>
          <Button
            variant="outline"
            onClick={() => copyToClipboard(output)}
            disabled={!output}
          >
            <CopyIcon /> Copy
          </Button>
        </div>
      </div>
    </div>
  )
}
```

### CodeMirror Integration

**Editor Component:**

```tsx
// @repo/ui/components/transformer/code-editor.tsx

import { EditorView, basicSetup } from 'codemirror'
import { javascript } from '@codemirror/lang-javascript'
import { json } from '@codemirror/lang-json'
import { css } from '@codemirror/lang-css'
import { html } from '@codemirror/lang-html'
// ... other language modes

interface CodeEditorProps {
  label: string
  value: string
  onChange?: (value: string) => void
  language?: string
  readOnly?: boolean
  error?: string
}

export function CodeEditor({
  label,
  value,
  onChange,
  language,
  readOnly,
  error,
}: CodeEditorProps) {
  const editorRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (!editorRef.current) return

    const extensions = [
      basicSetup,
      getLanguageExtension(language),
      EditorView.theme({}, { dark: isDarkMode }),
      readOnly ? EditorView.editable.of(false) : [],
    ]

    if (onChange) {
      extensions.push(
        EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            onChange(update.state.doc.toString())
          }
        }),
      )
    }

    const view = new EditorView({
      doc: value,
      extensions,
      parent: editorRef.current,
    })

    return () => view.destroy()
  }, [language, readOnly, isDarkMode])

  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      <div ref={editorRef} className="border rounded-lg overflow-hidden" />
      {error && <p className="text-sm text-destructive">{error}</p>}
    </div>
  )
}
```

### Content Sections

**Accordion-based content display:**

```tsx
// @repo/ui/components/content/content-sections.tsx

interface ContentSection {
  heading: string
  content: string // Markdown
}

export function ContentSectionsUi({
  sections,
}: {
  sections: ContentSection[]
}) {
  return (
    <Accordion
      type="multiple"
      defaultValue={[sections[0]?.heading]} // First expanded
      className="space-y-4"
    >
      {sections.map((section) => (
        <AccordionItem key={section.heading} value={section.heading}>
          <AccordionTrigger className="text-lg font-semibold">
            {section.heading}
          </AccordionTrigger>
          <AccordionContent>
            <Markdown>{section.content}</Markdown>
          </AccordionContent>
        </AccordionItem>
      ))}
    </Accordion>
  )
}
```

---

## Development Workflow

### Local Development Setup

#### Prerequisites

- **Node.js:** 20+ LTS (check with `node --version`)
- **pnpm:** 9.x (install with `npm install -g pnpm`)
- **Git:** Latest version
- **Google API Key:** For AI content generation

#### Initial Setup

```bash
# Clone repository
git clone https://github.com/benmvp/tools-app.git
cd tools-app

# Install dependencies
pnpm install

# Set up environment variables
cp .env.example .env.local

# Add your Google API key to .env.local
echo "GOOGLE_API_KEY=your_key_here" >> .env.local

# Start development servers for all apps
pnpm dev

# Or start individual apps
cd apps/codemata && pnpm dev
cd apps/moni && pnpm dev
cd apps/convertly && pnpm dev
```

#### Development Servers

Each app runs on its own port:

- **Codemata:** http://localhost:3001
- **Moni:** http://localhost:3002
- **Convertly:** http://localhost:3003

### Environment Variables

#### Required Variables

```bash
# .env.local (all apps)

# Google AI API Key (required for AI content generation)
GOOGLE_API_KEY=your_google_ai_api_key

# Node Environment (automatically set)
NODE_ENV=development
```

#### Optional Variables

```bash
# For manual revalidation
REVALIDATE_SECRET=your_secret_key_here

# Override AI model (default: gemini-2.0-flash)
AI_MODEL=gemini-2.0-flash

# Enable debug logging
DEBUG=true
```

### Package Scripts

#### Root Level Scripts

```json
{
  "scripts": {
    "dev": "turbo dev",
    "build": "turbo build",
    "start": "turbo start",
    "lint": "turbo lint",
    "type-check": "turbo type-check",
    "test": "turbo test",
    "format": "biome format --write .",
    "format:check": "biome check .",
    "clean": "turbo clean && rm -rf node_modules",
    "regenerate-ai": "node scripts/regenerate-ai.js"
  }
}
```

#### App-Specific Scripts

```json
{
  "scripts": {
    "dev": "next dev --port 3001",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "vitest"
  }
}
```

### Development Commands

#### Start Development

```bash
# All apps simultaneously
pnpm dev

# Single app
pnpm --filter codemata dev
pnpm --filter moni dev
pnpm --filter convertly dev

# With turbo caching
turbo dev --cache-dir=.turbo
```

#### Build for Production

```bash
# All apps
pnpm build

# Single app
pnpm --filter codemata build

# Check build output
ls -la apps/codemata/.next
```

#### Code Quality

```bash
# Lint all code
pnpm lint

# Fix linting issues
pnpm lint --fix

# Format code with Biome
pnpm format

# Check formatting without changes
pnpm format:check

# Type check all packages
pnpm type-check
```

#### AI Content Management

```bash
# Regenerate AI content for all tools
pnpm regenerate-ai

# Regenerate for specific app
pnpm regenerate-ai codemata

# Regenerate for specific tool
pnpm regenerate-ai codemata typescript-formatter

# Clear AI cache (development only)
rm -rf apps/*/app/.ai-cache
```

### Code Organization Patterns

#### File Naming Conventions

- **Components:** PascalCase - `TransformerUi.tsx`
- **Utilities:** kebab-case - `format-code.ts`
- **Types:** PascalCase - `FormatterTypes.ts`
- **Constants:** UPPER_SNAKE_CASE - `FORMATTER_INFO.ts`
- **Hooks:** camelCase with prefix - `useTheme.ts`

#### Import Order

```typescript
// 1. External libraries
import { useState } from 'react'
import { Button } from '@repo/ui/button'

// 2. Internal utilities
import { formatCode } from '@/lib/utils'

// 3. Types
import type { FormatterConfig } from './types'

// 4. Relative imports
import { FormatterInfo } from './info'
```

#### Component Structure

```typescript
// Type definitions first
interface ComponentProps {
  // ...
}

// Component implementation
export function Component({ prop1, prop2 }: ComponentProps) {
  // 1. Hooks
  const [state, setState] = useState()

  // 2. Derived values
  const computed = useMemo(() => /* ... */, [state])

  // 3. Event handlers
  const handleClick = () => {
    // ...
  }

  // 4. Effects
  useEffect(() => {
    // ...
  }, [])

  // 5. Render
  return <div>{/* ... */}</div>
}
```

#### Server Action Pattern

```typescript
// actions.ts
'use server'

import { z } from 'zod'

// Input validation schema
const inputSchema = z.object({
  code: z.string().min(1),
  config: z.object({
    // ...
  }),
})

export async function formatCodeAction(
  input: string,
  config: FormatterConfig,
): Promise<string> {
  // Validate input
  const validated = inputSchema.parse({ code: input, config })

  // Perform transformation
  try {
    const result = await transform(validated.code, validated.config)
    return result
  } catch (error) {
    // Throw with user-friendly message
    throw new Error(formatErrorMessage(error))
  }
}
```

### Git Workflow

#### Branch Strategy

- **main:** Production-ready code
- **feature/\*:** New features (`feature/add-rust-formatter`)
- **fix/\*:** Bug fixes (`fix/json-minifier-error`)
- **chore/\*:** Maintenance (`chore/upgrade-dependencies`)

#### Commit Convention

```bash
# Format: <type>(<scope>): <subject>

# Types: feat, fix, docs, style, refactor, test, chore

# Examples:
git commit -m "feat(codemata): add rust formatter"
git commit -m "fix(ui): resolve dark mode toggle issue"
git commit -m "chore: upgrade Next.js to 15.1"
git commit -m "docs: update README with setup instructions"
```

#### Pull Request Process

1. Create feature branch from `main`
2. Make changes and commit
3. Push to GitHub
4. Open PR with description
5. Wait for checks to pass:
   - **GitHub Actions CI:** Lint, format, type-check, test
   - **Vercel:** Preview deployment build
6. Request review if needed
7. Merge to `main`
8. Vercel auto-deploys to production

### Continuous Integration (GitHub Actions)

#### CI Workflow Overview

GitHub Actions runs automated checks on every push and pull request:

- **Lint:** Code quality checks with Biome
- **Format Check:** Code formatting verification
- **Type Check:** TypeScript compilation
- **Test:** Run unit tests with Vitest

_Note: Build verification is handled by Vercel during deployment._

#### Main CI Workflow

**.github/workflows/ci.yml:**

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  ci:
    name: CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm lint

      - name: Format check
        run: pnpm format:check

      - name: Type check
        run: pnpm type-check

      - name: Test
        run: pnpm test --run
```

#### Test Coverage (Optional Enhancement)

To track test coverage over time, add coverage upload:

**.github/workflows/ci.yml** (add after test step):

```yaml
- name: Test with coverage
  run: pnpm test --run --coverage

- name: Upload coverage to Codecov
  uses: codecov/codecov-action@v4
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  with:
    files: ./coverage/coverage-final.json
    token: ${{ secrets.CODECOV_TOKEN }}
```

_Note: Requires setting up a [Codecov](https://codecov.io) account and adding `CODECOV_TOKEN` secret._

#### Branch Protection Rules

Configure in **Settings → Branches → Branch protection rules** for `main`:

- ✅ Require a pull request before merging
- ✅ Require status checks to pass before merging
  - Select: `CI` (or individual checks: `Lint`, `Test`, etc.)
- ✅ Require branches to be up to date before merging
- ✅ Do not allow bypassing the above settings

_Note: Build verification happens automatically in Vercel preview deployments._

#### CI Performance

The CI workflow typically completes in **2-4 minutes**:

- Install dependencies: ~30s (with cache)
- Lint: ~10s
- Format check: ~5s
- Type check: ~30s
- Tests: ~1-2min

Total: ~2-4 minutes per run

#### Workflow Badges

Add status badges to README.md:

```markdown
[![CI](https://github.com/benmvp/tools-app/actions/workflows/ci.yml/badge.svg)](https://github.com/benmvp/tools-app/actions/workflows/ci.yml)
```

### Debugging

#### Next.js Debugging

```bash
# Enable verbose logging
NODE_OPTIONS='--inspect' pnpm dev

# Debug in VS Code: .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "pnpm dev"
    }
  ]
}
```

#### AI Generation Debugging

```typescript
// In ai.ts, enable debug logging
const DEBUG = process.env.DEBUG === 'true'

if (DEBUG) {
  console.log('AI Request:', { systemMessage, userMessage })
  console.log('AI Response:', response)
}
```

#### Common Issues

**Issue:** AI generation fails during build

```bash
# Check API key
echo $GOOGLE_API_KEY

# Test API key
curl -H "Content-Type: application/json" \
  -d '{"contents":[{"parts":[{"text":"Say hello"}]}]}' \
  "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=$GOOGLE_API_KEY"
```

**Issue:** Port already in use

```bash
# Kill process on port
lsof -ti:3001 | xargs kill -9

# Use different port
pnpm dev -- --port 3010
```

**Issue:** Type errors after updating dependencies

```bash
# Clear cache and reinstall
rm -rf node_modules .next .turbo
pnpm install
pnpm type-check
```

---

## Testing Strategy

### Testing Philosophy

Focus on **unit tests for core transformation logic** to ensure accuracy. E2E and integration tests can be added in future phases.

### Test Stack

- **Framework:** Vitest (fast, Vite-compatible)
- **React Testing:** @testing-library/react
- **Assertions:** Vitest's built-in assertions
- **Coverage:** v8 (built into Vitest)

### Test Structure

```
apps/codemata/
├── app/
│   └── formatters/
│       ├── actions.ts
│       └── actions.test.ts       # Test file alongside source
├── lib/
│   ├── transform.ts
│   └── transform.test.ts
└── vitest.config.ts
```

### Unit Tests for Transformers

**Test Pattern:**

```typescript
// apps/codemata/app/formatters/actions.test.ts

import { describe, it, expect } from 'vitest'
import { formatTypescriptAction } from './actions'

describe('formatTypescriptAction', () => {
  it('formats valid TypeScript code', async () => {
    const input = 'const x=1;const y=2;'
    const config = { indentation: 'two-spaces' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toMatchSnapshot()
    expect(result).toContain('const x = 1')
    expect(result).toContain('const y = 2')
  })

  it('handles invalid TypeScript gracefully', async () => {
    const input = 'const x = {'
    const config = { indentation: 'two-spaces' }

    await expect(formatTypescriptAction(input, config)).rejects.toThrow()
  })

  it('respects indentation config - two spaces', async () => {
    const input = 'function test(){return true}'
    const config = { indentation: 'two-spaces' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toContain('  return') // Two spaces
  })

  it('respects indentation config - four spaces', async () => {
    const input = 'function test(){return true}'
    const config = { indentation: 'four-spaces' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toContain('    return') // Four spaces
  })

  it('respects indentation config - tabs', async () => {
    const input = 'function test(){return true}'
    const config = { indentation: 'tabs' }

    const result = await formatTypescriptAction(input, config)

    expect(result).toContain('\treturn') // Tab character
  })
})
```

### Test Fixtures

```typescript
// apps/codemata/app/formatters/__fixtures__/typescript.ts

export const UNFORMATTED_TS = `
const x=1;const y=2;
function test(){return x+y}
`

export const FORMATTED_TS_TWO_SPACES = `
const x = 1
const y = 2
function test() {
  return x + y
}
`

export const INVALID_TS = `const x = {`
```

**Using Fixtures:**

```typescript
import {
  UNFORMATTED_TS,
  FORMATTED_TS_TWO_SPACES,
} from './__fixtures__/typescript'

it('formats TypeScript correctly', async () => {
  const result = await formatTypescriptAction(UNFORMATTED_TS, {
    indentation: 'two-spaces',
  })

  expect(result.trim()).toBe(FORMATTED_TS_TWO_SPACES.trim())
})
```

### Snapshot Testing

```typescript
it('formats complex TypeScript correctly', async () => {
  const input = fs.readFileSync('__fixtures__/complex.ts', 'utf-8')
  const result = await formatTypescriptAction(input, {
    indentation: 'two-spaces',
  })

  expect(result).toMatchSnapshot()
})
```

### Vitest Configuration

```typescript
// apps/codemata/vitest.config.ts

import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '.next/',
        'vitest.config.ts',
        '**/*.test.ts',
        '**/*.test.tsx',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
})
```

### Running Tests

```bash
# Run all tests
pnpm test

# Run tests in watch mode
pnpm test --watch

# Run tests for specific app
pnpm --filter codemata test

# Run tests with coverage
pnpm test --coverage

# Run specific test file
pnpm test formatters/actions.test.ts

# Update snapshots
pnpm test -u
```

### Test Coverage Goals

- **Transformation Actions:** 100% coverage
- **Utility Functions:** 90%+ coverage
- **Components:** Defer to future phase
- **AI Generation:** Manual testing (expensive to test)

### Manual Testing Checklist

Before each release, manually test:

**Formatters:**

- [ ] Paste unformatted code
- [ ] Select indentation option
- [ ] Verify formatted output
- [ ] Copy to clipboard works
- [ ] Error handling for invalid input
- [ ] Dark mode toggle
- [ ] Mobile responsive layout

**AI Content:**

- [ ] All tool pages load
- [ ] SEO metadata present
- [ ] Content sections render
- [ ] Links to related tools work
- [ ] External resource links work

**Cross-Browser:**

- [ ] Chrome (latest)
- [ ] Firefox (latest)
- [ ] Safari (latest)
- [ ] Mobile Safari (iOS)
- [ ] Mobile Chrome (Android)

---

## Deployment & Infrastructure

### Hosting Platform

**Vercel** - Optimized for Next.js applications

#### Why Vercel?

- Native Next.js support
- Automatic deployments from GitHub
- ISR (Incremental Static Regeneration) support
- Edge Network for global performance
- Free SSL certificates
- Environment variable management
- Preview deployments for PRs

### Deployment Configuration

#### Vercel Projects

Each app is a separate Vercel project:

1. **codemata** → codemata.benmvp.com
2. **moni** → moni.benmvp.com
3. **convertly** → convertly.benmvp.com

#### Project Settings

**Root Directory:** Each project points to its app directory

- Codemata: `apps/codemata`
- Moni: `apps/moni`
- Convertly: `apps/convertly`

**Build Settings:**

```bash
# Build Command
cd ../.. && pnpm install && pnpm --filter codemata build

# Output Directory
.next

# Install Command
pnpm install
```

**Framework Preset:** Next.js

### Domain Configuration

#### DNS Setup

Configure DNS records at your domain provider:

```
# Codemata
CNAME codemata.benmvp.com -> cname.vercel-dns.com

# Moni
CNAME moni.benmvp.com -> cname.vercel-dns.com

# Convertly
CNAME convertly.benmvp.com -> cname.vercel-dns.com
```

#### Vercel Domain Setup

1. Go to Project Settings → Domains
2. Add custom domain
3. Verify ownership
4. SSL automatically provisioned

### Environment Variables

#### Production Environment Variables

Configure in Vercel Dashboard → Settings → Environment Variables:

```bash
# Required for all apps
GOOGLE_API_KEY=your_production_api_key
NODE_ENV=production

# Optional
REVALIDATE_SECRET=your_secret_for_manual_revalidation
AI_MODEL=gemini-2.0-flash
DEBUG=false
```

**Environment Scope:**

- Production: Used for main branch deployments
- Preview: Used for PR preview deployments
- Development: Not used (local only)

### Deployment Workflow

#### Automatic Deployments

```mermaid
Push to GitHub → Vercel detects changes → Build starts
                                            ↓
                                    AI generates content
                                            ↓
                                    Next.js build
                                            ↓
                                    Deploy to production
                                            ↓
                                    Invalidate CDN cache
```

**Branches:**

- `main` branch → Production deployment
- Pull requests → Preview deployments
- Other branches → No automatic deployment

#### Manual Deployment

```bash
# Install Vercel CLI
pnpm add -g vercel

# Login
vercel login

# Deploy to preview
vercel

# Deploy to production
vercel --prod
```

### Build Configuration

#### Next.js Configuration

```typescript
// apps/codemata/next.config.mjs

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Enable ISR
  experimental: {
    // Any experimental features
  },

  // Output: standalone for Node.js runtime
  output: 'standalone',

  // Image optimization
  images: {
    domains: [],
  },

  // Redirects
  async redirects() {
    return []
  },

  // Headers for security
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
        ],
      },
    ]
  },

  // Transpile shared packages
  transpilePackages: ['@repo/ui'],
}

export default nextConfig
```

#### Build Performance

**Build Time Expectations:**

- Without AI generation (cached): 2-3 minutes
- With AI generation: 5-10 minutes (generates content for all tools)
- Large number of tools may increase build time

**Optimization:**

```typescript
// Parallel AI generation
const contentPromises = Object.keys(FORMATTERS_INFO).map((id) =>
  getFormatterContent(id),
)
await Promise.all(contentPromises)
```

### ISR Configuration

#### Page-Level ISR

```typescript
// apps/codemata/app/formatters/[slug]/page.tsx

// Revalidate every 24 hours
export const revalidate = 86400

// Or use time constants
const ONE_DAY = 60 * 60 * 24
export const revalidate = ONE_DAY
```

#### On-Demand Revalidation

```typescript
// apps/codemata/app/api/revalidate/route.ts

import { revalidatePath } from 'next/cache'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const secret = request.nextUrl.searchParams.get('secret')
  const path = request.nextUrl.searchParams.get('path')

  // Validate secret
  if (secret !== process.env.REVALIDATE_SECRET) {
    return NextResponse.json({ message: 'Invalid secret' }, { status: 401 })
  }

  // Validate path
  if (!path) {
    return NextResponse.json({ message: 'Missing path' }, { status: 400 })
  }

  try {
    await revalidatePath(path)
    return NextResponse.json({ revalidated: true, path })
  } catch (err) {
    return NextResponse.json({ message: 'Error revalidating' }, { status: 500 })
  }
}
```

**Trigger Revalidation:**

```bash
curl "https://codemata.benmvp.com/api/revalidate?path=/typescript-formatter&secret=YOUR_SECRET"
```

### Monitoring & Analytics

#### Future: Google Analytics

When ready to add analytics:

```typescript
// app/layout.tsx
import Script from 'next/script'

export default function RootLayout({ children }) {
  return (
    <html>
      <head>
        {process.env.NODE_ENV === 'production' && (
          <>
            <Script
              src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_ID}`}
              strategy="afterInteractive"
            />
            <Script id="google-analytics" strategy="afterInteractive">
              {`
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', '${process.env.NEXT_PUBLIC_GA_ID}');
              `}
            </Script>
          </>
        )}
      </head>
      <body>{children}</body>
    </html>
  )
}
```

#### Future: Google Ads

```typescript
// components/ad-banner.tsx
export function AdBanner({ slot }: { slot: string }) {
  useEffect(() => {
    try {
      ;(window.adsbygoogle = window.adsbygoogle || []).push({})
    } catch (err) {
      console.error('Ad error:', err)
    }
  }, [])

  return (
    <ins
      className="adsbygoogle"
      style={{ display: 'block' }}
      data-ad-client={process.env.NEXT_PUBLIC_ADSENSE_ID}
      data-ad-slot={slot}
      data-ad-format="auto"
      data-full-width-responsive="true"
    />
  )
}
```

### Performance Optimization

#### Caching Strategy

```typescript
// Static assets: Cache for 1 year
// API routes: No cache
// Pages: ISR (24 hours)

// next.config.mjs
const nextConfig = {
  async headers() {
    return [
      {
        source: '/static/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ]
  },
}
```

#### Image Optimization

```typescript
// Use Next.js Image component
import Image from 'next/image'

<Image
  src="/logo.svg"
  alt="Logo"
  width={200}
  height={50}
  priority // For above-fold images
/>
```

#### Code Splitting

```typescript
// Lazy load heavy components
const CodeEditor = dynamic(() => import('./code-editor'), {
  loading: () => <Skeleton />,
  ssr: false, // Client-side only if needed
})
```

### Security

#### Environment Variables

- Never commit `.env.local` to git
- Use Vercel's environment variable UI
- Rotate API keys periodically

#### Content Security Policy

```typescript
// next.config.mjs
const nextConfig = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'Content-Security-Policy',
            value: [
              "default-src 'self'",
              "script-src 'self' 'unsafe-eval' 'unsafe-inline'",
              "style-src 'self' 'unsafe-inline'",
              "img-src 'self' data: https:",
              'font-src "self" data:',
            ].join('; '),
          },
        ],
      },
    ]
  },
}
```

### Backup & Recovery

#### Code Backup

- **GitHub:** Primary source of truth
- **Vercel:** Automatic deployments history
- **Tags:** Git tags for release versions

```bash
# Tag releases
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0
```

#### Rollback Strategy

```bash
# Revert to previous deployment in Vercel
# Via Vercel Dashboard → Deployments → Previous → Promote to Production

# Or revert git commit
git revert HEAD
git push origin main
```

---

## Implementation Plan

### Overview

The implementation is divided into **5 phases** that can be completed progressively. Each phase delivers working functionality and builds on the previous phase.

### Phase 1: Foundation & Infrastructure (Week 1-2)

**Goal:** Set up monorepo, shared packages, and basic project structure

#### Tasks

**1.1 Monorepo Setup**

- [ ] Initialize new repository (or clean current one)
- [ ] Configure pnpm workspace
- [ ] Set up Turborepo
- [ ] Create base directory structure
- [ ] Configure root `package.json` with scripts

**1.2 Shared Packages**

- [ ] Create `@repo/typescript-config` package
  - [ ] `base.json` - Strict TypeScript config
  - [ ] `nextjs.json` - Next.js specific settings
- [ ] Create `@repo/eslint-config` package
  - [ ] `base.js` - Base ESLint rules
  - [ ] `next.js` - Next.js specific rules
- [ ] Create `@repo/ui` package structure
  - [ ] Set up Tailwind CSS
  - [ ] Configure shadcn/ui
  - [ ] Install core components (button, card, accordion, etc.)

**1.3 Base Components**

- [ ] Create theme system (types, context, provider)
- [ ] Build `BaseRootLayout` component
- [ ] Build `Header` component (logo, nav, theme toggle)
- [ ] Build `Footer` component
- [ ] Build `ThemeProvider` with dark mode support

**1.4 Development Setup**

- [ ] Configure Biome for linting/formatting
- [ ] Set up VS Code workspace settings
- [ ] Create `.env.example` file
- [ ] Document setup in README

**1.5 GitHub Actions / CI Setup**

- [ ] Create `.github/workflows/` directory
- [ ] Set up main CI workflow (`ci.yml`)
  - [ ] Lint checks
  - [ ] Format checks
  - [ ] Type checking
  - [ ] Unit tests
- [ ] Configure pnpm caching for faster runs
- [ ] Set up branch protection rules for `main`
- [ ] Add CI status badges to README
- [ ] Test CI pipeline with sample PR

**Deliverable:** Working monorepo with shared packages, basic UI components, and automated CI

---

### Phase 2: Codemata App - Core Structure (Week 3-4)

**Goal:** Build Codemata app with one working formatter (TypeScript)

#### Tasks

**2.1 App Initialization**

- [ ] Create Next.js app in `apps/codemata`
- [ ] Configure Next.js 15 with App Router
- [ ] Set up Tailwind with Codemata theme
- [ ] Configure TypeScript
- [ ] Add shared packages as dependencies
- [ ] Verify CI pipeline runs successfully for new app

**2.2 Type Definitions**

- [ ] Define `FormatterId` type
- [ ] Define `Formatter` interface
- [ ] Define `TransformerConfig` type
- [ ] Define `FormatterInfo` type
- [ ] Create `types.ts` file

**2.3 TypeScript Formatter (First Tool)**

- [ ] Create `app/formatters/` directory
- [ ] Define formatter info in `info.ts`
- [ ] Configure formatter in `formatters.ts`
- [ ] Implement `formatTypescriptAction` in `actions.ts`
- [ ] Set up Prettier/Biome integration
- [ ] Handle indentation configuration

**2.4 Tool Page**

- [ ] Create `app/formatters/[slug]/page.tsx`
- [ ] Implement `generateStaticParams()`
- [ ] Implement `generateMetadata()`
- [ ] Build page layout (title + intro + transformer)
- [ ] Test TypeScript formatter end-to-end

**2.5 Transformer Component**

- [ ] Build dual editor layout (input/output)
- [ ] Integrate CodeMirror 6
- [ ] Add language mode switching
- [ ] Implement configuration panel
- [ ] Add action button with loading state
- [ ] Add copy to clipboard button
- [ ] Handle errors with inline messages + toast

**2.6 Home Page**

- [ ] Create `app/page.tsx`
- [ ] Build hero section
- [ ] Create category cards (Formatters, Minifiers)
- [ ] Add tool grid with links
- [ ] Make responsive

**Deliverable:** Working Codemata app with TypeScript formatter

---

### Phase 3: Complete Codemata Tools (Week 5-6)

**Goal:** Add all remaining formatters and minifiers

#### Tasks

**3.1 Remaining Formatters**

- [ ] CSS/SCSS formatter
- [ ] GraphQL formatter
- [ ] HTML formatter
- [ ] JSON formatter
- [ ] Markdown/MDX formatter
- [ ] XML formatter (with @prettier/plugin-xml)
- [ ] YAML formatter

**3.2 Minifiers**

- [ ] Create `app/minifiers/` directory
- [ ] CSS minifier (clean-css)
- [ ] HTML minifier (html-minifier-terser)
- [ ] JSON minifier (native)
- [ ] SVG minifier (svgo)
- [ ] TypeScript minifier (terser)
- [ ] XML minifier (minify-xml)

**3.3 Testing**

- [ ] Set up Vitest
- [ ] Write unit tests for each formatter action
- [ ] Write unit tests for each minifier action
- [ ] Create test fixtures
- [ ] Achieve 90%+ coverage on actions

**3.4 Polish**

- [ ] Add loading states
- [ ] Improve error messages
- [ ] Test all tools manually
- [ ] Mobile responsive testing
- [ ] Dark mode testing

**Deliverable:** Complete Codemata with all 8 formatters + 6 minifiers

---

### Phase 4: AI Content Integration (Week 7-8)

**Goal:** Integrate Gemini AI for content generation

#### Tasks

**4.1 AI Setup**

- [ ] Install Google AI SDK
- [ ] Set up `GOOGLE_API_KEY` environment variable
- [ ] Create `app/ai.ts` with Gemini client
- [ ] Configure structured output with Zod

**4.2 Content Schema**

- [ ] Define `toolContentSchema` with Zod
- [ ] Define all content section types
- [ ] Set up validation and error handling
- [ ] Test schema with sample Gemini responses

**4.3 AI Prompts**

- [ ] Write system message template
- [ ] Write user message template
- [ ] Create prompt function for formatters
- [ ] Create prompt function for minifiers
- [ ] Test prompts with Gemini API

**4.4 Content Generation**

- [ ] Implement `getFormatterContent()` function
- [ ] Implement `getMinifierContent()` function
- [ ] Add caching strategy (in-memory + ISR)
- [ ] Handle API failures gracefully
- [ ] Test build with AI generation

**4.5 Content Display**

- [ ] Build `ContentSection` component
- [ ] Build `ContentSections` component with accordion
- [ ] Integrate Markdown rendering
- [ ] Update tool pages to show AI content
- [ ] Ensure first section expanded, rest collapsed

**4.6 Metadata Integration**

- [ ] Update `generateMetadata()` to use AI content
- [ ] Add SEO title, description, keywords
- [ ] Test with various tools

**4.7 ISR Configuration**

- [ ] Set `revalidate = 86400` on tool pages
- [ ] Create `/api/revalidate` endpoint
- [ ] Test on-demand revalidation
- [ ] Document regeneration process

**4.8 Manual Regeneration Script**

- [ ] Create `scripts/regenerate-ai.js`
- [ ] Add CLI argument parsing
- [ ] Implement revalidation logic
- [ ] Test script locally and in production

**Deliverable:** Codemata with full AI-generated content and SEO

---

### Phase 5: Moni & Convertly Apps (Week 9-12)

**Goal:** Build Moni and Convertly apps with initial tools

#### Tasks

**5.1 Moni App Setup**

- [ ] Create Next.js app in `apps/moni`
- [ ] Configure Moni theme (green)
- [ ] Set up directory structure
- [ ] Create home page with hero

**5.2 Moni - First Calculators (Priority)**

- [ ] Compound Interest Calculator
  - [ ] Define input schema
  - [ ] Build calculator form
  - [ ] Implement calculation logic (server action)
  - [ ] Display results with chart
  - [ ] Add AI content generation
- [ ] Savings Goal Calculator
- [ ] Loan/Mortgage Calculator

**5.3 Moni - Additional Calculators**

- [ ] Retirement Calculator
- [ ] Credit Card Payoff Calculator
- [ ] Investment Return Calculator
- [ ] (See TODO.md for full list)

**5.4 Convertly App Setup**

- [ ] Create Next.js app in `apps/convertly`
- [ ] Configure Convertly theme (purple)
- [ ] Set up directory structure
- [ ] Create home page with hero

**5.5 Convertly - First Converters**

- [ ] Length Converter
  - [ ] Define units and conversion factors
  - [ ] Build converter UI (input → output)
  - [ ] Implement conversion logic
  - [ ] Add AI content generation
- [ ] Temperature Converter
- [ ] Weight Converter

**5.6 Convertly - Additional Converters**

- [ ] Volume, Area, Speed converters
- [ ] Time Zone Converter
- [ ] Data Size Converter
- [ ] (See TODO.md for full list)

**5.7 Testing**

- [ ] Unit tests for calculator logic
- [ ] Unit tests for conversion logic
- [ ] Manual testing all tools

**Deliverable:** All three apps deployed with initial tool set

---

### Phase 6: Production Launch & Polish (Week 13-14)

**Goal:** Deploy to production and optimize

#### Tasks

**6.1 Deployment Setup**

- [ ] Create Vercel projects for all three apps
- [ ] Configure custom domains
- [ ] Set up environment variables
- [ ] Configure build settings

**6.2 SEO Optimization**

- [ ] Add `robots.txt`
- [ ] Add `sitemap.xml` (dynamic)
- [ ] Verify all metadata present
- [ ] Test with Google Search Console
- [ ] Submit sitemaps

**6.3 Performance Optimization**

- [ ] Run Lighthouse audits
- [ ] Optimize images
- [ ] Minimize bundle size
- [ ] Test ISR performance
- [ ] Test build times

**6.4 Cross-Browser Testing**

- [ ] Chrome
- [ ] Firefox
- [ ] Safari
- [ ] Mobile Safari
- [ ] Mobile Chrome

**6.5 Documentation**

- [ ] Update README with project overview
- [ ] Document development setup
- [ ] Document deployment process
- [ ] Create contributing guidelines (if open source)

**6.6 Monitoring Setup**

- [ ] Set up error tracking (Sentry or similar)
- [ ] Add basic logging
- [ ] Monitor build times
- [ ] Monitor ISR revalidation

**Deliverable:** Production-ready apps deployed at custom domains

---

### Phase 7: Future Enhancements (Ongoing)

**Goal:** Add analytics, ads, and expand tool offerings

#### Tasks

**7.1 Analytics & Monetization**

- [ ] Integrate Google Analytics
- [ ] Track tool usage events
- [ ] Set up Google AdSense
- [ ] Add ad placements (non-intrusive)
- [ ] Monitor ad performance

**7.2 Expand Codemata**

- [ ] Add viewers (SVG, Markdown, Diff)
- [ ] Add validators (HTML, JSON, XML)
- [ ] Add encoders/decoders
- [ ] Add generators (Hash, UUID, QR codes)
- [ ] (See TODO.md)

**7.3 Expand Moni**

- [ ] Add more calculators
- [ ] Add data visualization
- [ ] Add save/export functionality

**7.4 Expand Convertly**

- [ ] Add more converters
- [ ] Add conversion history
- [ ] Add favorites/bookmarks

**7.5 User Enhancements**

- [ ] Add keyboard shortcuts
- [ ] Add example snippets
- [ ] Add "Clear" buttons
- [ ] Add settings persistence (optional)

---

### Milestones Summary

| Phase | Duration | Key Deliverable              |
| ----- | -------- | ---------------------------- |
| 1     | 2 weeks  | Monorepo + Shared Packages   |
| 2     | 2 weeks  | Codemata with 1 formatter    |
| 3     | 2 weeks  | Complete Codemata (14 tools) |
| 4     | 2 weeks  | AI Content Integration       |
| 5     | 4 weeks  | Moni + Convertly apps        |
| 6     | 2 weeks  | Production deployment        |
| 7     | Ongoing  | Analytics + Expansion        |

**Total Initial Build:** ~14 weeks (3.5 months)

---

## Future Enhancements

### Near-Term (Next 3-6 months)

**Analytics & Monetization:**

- Google Analytics 4 integration
- Track tool usage and popular tools
- Google AdSense integration
- Strategic ad placement (below tool, in content)
- Monitor revenue and optimize placement

**SEO Improvements:**

- Blog section with coding tips
- Tool comparison pages
- "How-to" guides for each tool
- Internal linking strategy
- Schema.org structured data

**User Experience:**

- Keyboard shortcuts (Cmd+Enter to format)
- Example code snippets ("Load Example")
- Recent tools history (localStorage)
- Favorite tools bookmarking
- Share formatted code (generate link)

### Mid-Term (6-12 months)

**Codemata Expansion (See TODO.md):**

- **Viewers:** SVG Viewer, Markdown Preview, Diff Tool
- **Validators:** HTML, JSON, XML, CSS, A11Y, SEO checkers
- **Encoders/Decoders:** JWT, Base64, URL, HTML entities
- **Generators:** Hash (MD5, SHA), UUID, QR codes, Meta tags
- **Converters:** XML ↔ JSON, CSV ↔ JSON, YAML ↔ JSON
- **Colors:** Color converter, gradient generator, scheme creator
- **Text Tools:** Case converter, text analyzer, line tools
- **Network Tools:** IP lookup, WHOIS, DNS lookup

**Moni Expansion:**

- All calculators from TODO.md
- Interactive charts and visualizations
- PDF export functionality
- Save calculations (with account)
- Compare scenarios side-by-side

**Convertly Expansion:**

- All converters from TODO.md
- Unit favorites
- Conversion history
- Batch conversions
- API access (premium feature?)

### Long-Term (12+ months)

**Platform Features:**

- User accounts (optional)
- Save favorites and history
- API access for tools
- Browser extension
- Mobile apps (React Native)

**Community Features:**

- User-contributed tools
- Tool ratings and reviews
- Code snippet sharing
- Forum/discussions

**Enterprise Features:**

- Teams/workspaces
- Custom branding
- Private deployment
- SLA guarantees
- Priority support

**AI Enhancements:**

- AI code review
- AI bug detection
- AI code explanation
- AI refactoring suggestions
- Multi-model support (Claude, GPT)

### Continuous Improvements

**Performance:**

- Optimize bundle sizes
- Improve ISR cache strategy
- Add service worker for offline support
- Optimize AI generation (parallel, caching)

**Quality:**

- Expand test coverage
- Add E2E tests with Playwright
- Add visual regression testing
- Automated accessibility testing

**Developer Experience:**

- Storybook for component development
- Better error messages
- Improved debugging tools
- More comprehensive docs

**Security:**

- Rate limiting on API routes
- CAPTCHA for abuse prevention
- Content Security Policy hardening
- Regular dependency updates

---

## Appendix

### Useful Resources

**Documentation:**

- [Next.js Docs](https://nextjs.org/docs)
- [Tailwind CSS](https://tailwindcss.com/docs)
- [Radix UI](https://www.radix-ui.com/primitives)
- [shadcn/ui](https://ui.shadcn.com/)
- [CodeMirror](https://codemirror.net/)
- [Gemini API](https://ai.google.dev/docs)
- [Vercel Docs](https://vercel.com/docs)
- [Turborepo Docs](https://turbo.build/repo/docs)

**Tools:**

- [Biome](https://biomejs.dev/) - Linter and formatter
- [Prettier](https://prettier.io/) - Code formatter
- [Terser](https://terser.org/) - JS minifier
- [Vitest](https://vitest.dev/) - Test framework

### Contact & Repository

- **GitHub:** https://github.com/benmvp/tools-app
- **Issues:** Use GitHub Issues for bugs and features
- **Discussions:** Use GitHub Discussions for questions

---

**End of Specification Document**

_This document is a living specification and will be updated as the project evolves._
